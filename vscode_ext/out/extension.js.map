{"version":3,"file":"extension.js","mappings":";;;;;;;AAAA,gEAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,2BAA2B;AACvF;AACA,2DAA2D,aAAa;AACxE;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA;AACA,6BAA6B,4FAA4F;AACzH;AACA;AACA;AACA,mGAAmG;AACnG;AACA;AACA;AACA;AACA,yEAAyE,8BAA8B;AACvG;AACA;AACA,oDAAoD,kBAAkB,aAAa;;AAEnF;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,IAAgC;AAC1C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,GAAI;AAC/B,yBAAyB,mBAAO,CAAC,GAAM;AACvC;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,0DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,cAAc;AACd,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yBAAyB;AACtD;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8BAA8B;AAC9B,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB,kDAAkD,QAAQ,KAAK,aAAa;AAC5E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,qCAAqC;AACrC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,+BAA+B,KAAK,OAAO,EAAE,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,OAAO,MAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB,wDAAwD,QAAQ,KAAK,aAAa;AAClF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM,SAAS,IAA6C;AAC5D,MAAM,iCAAO,EAAE,mCAAE,YAAY;AAAA,kGAAC;AAC9B;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,iCAAiC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kCAAkC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qBAAqB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA,MAAM,0BAA0B;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C,0CAA0C,8BAA8B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gCAAgC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kBAAkB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,qBAAqB;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gCAAgC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B;AACA,UAAU,iBAAiB,0BAA0B,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA,kCAAkC,WAAW;AAC7C;AACA,oCAAoC,WAAW;AAC/C;AACA,kDAAkD,aAAa;AAC/D;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS,gCAAgC,iBAAiB;AACnG;AACA;AACA;AACA;AACA,8BAA8B,SAAS,uCAAuC,eAAe;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS,gCAAgC,iBAAiB;AACnG;AACA;AACA;AACA;AACA,8BAA8B,SAAS,uCAAuC,eAAe;AAC7F;AACA;AACA;AACA;AACA,+BAA+B,SAAS,sCAAsC,cAAc;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS,yCAAyC,iBAAiB;AAC5G;AACA;AACA;AACA;AACA,8BAA8B,SAAS,uCAAuC,eAAe;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS,qCAAqC,iBAAiB;AACxG;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,iBAAiB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8BAA8B;AAC/C,IAAI;AACJ,iBAAiB,kDAAkD;AACnE,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oCAAoC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW,WAAW,KAAK,OAAO,OAAO;AACjG;AACA,0CAA0C,MAAM;AAChD;AACA,0CAA0C,MAAM;AAChD;AACA,0CAA0C,MAAM;AAChD;AACA,0CAA0C,WAAW,WAAW,KAAK,OAAO,OAAO;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA,aAAa,cAAc;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA,aAAa,cAAc;AAC3B;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc,2BAA2B,uBAAuB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc,2BAA2B,uBAAuB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc,2BAA2B,uBAAuB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2BAA2B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA,kBAAkB,oCAAoC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,aAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,0BAA0B,8FAAqB;AAC/C;AACA,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA,gEAAgE,gBAAgB;;AAEhF,EAAE,MAAM;AACR;AACA,SAAS;AACT;AACA;AACA,6DAA6D,iBAAiB;AAC9E;AACA;AACA;AACA;AACA,EAAE,qCAAqC;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,wBAAwB;AAC9B,MAAM,wBAAwB,KAAK,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,2CAA2C,QAAQ,wBAAwB,wBAAwB,UAAU,iBAAiB;AAC9H;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wBAAwB;AACrC;AACA,aAAa,aAAa;AAC1B;AACA,2BAA2B,gBAAgB;AAC3C;AACA,aAAa,cAAc;AAC3B;AACA;AACA,eAAe,aAAa,GAAG,YAAY;AAC3C,6DAA6D,yBAAyB;AACtF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,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","sources":[".././node_modules/web-tree-sitter/tree-sitter.cjs",".././src/extension.ts","../external commonjs \"vscode\"","../external node-commonjs \"fs\"","../external node-commonjs \"path\"","../external node-commonjs \"fs/promises\"","../webpack/bootstrap","../webpack/runtime/create fake namespace object","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/before-startup","../webpack/startup","../webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name2 in all)\n    __defProp(target, name2, { get: all[name2], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// lib/tree-sitter.cjs\nvar require_tree_sitter = __commonJS({\n  \"lib/tree-sitter.cjs\"(exports, module) {\n    \"use strict\";\n    var Module = (() => {\n      var _scriptName = typeof document != \"undefined\" ? document.currentScript?.src : void 0;\n      if (typeof __filename != \"undefined\") _scriptName = _scriptName || __filename;\n      return async function(moduleArg = {}) {\n        var moduleRtn;\n        var Module = moduleArg;\n        var readyPromiseResolve, readyPromiseReject;\n        var readyPromise = new Promise((resolve, reject) => {\n          readyPromiseResolve = resolve;\n          readyPromiseReject = reject;\n        });\n        var ENVIRONMENT_IS_WEB = typeof window == \"object\";\n        var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != \"undefined\";\n        var ENVIRONMENT_IS_NODE = typeof process == \"object\" && typeof process.versions == \"object\" && typeof process.versions.node == \"string\" && process.type != \"renderer\";\n        var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n        if (ENVIRONMENT_IS_NODE) {\n        }\n        Module.currentQueryProgressCallback = null;\n        Module.currentProgressCallback = null;\n        Module.currentLogCallback = null;\n        Module.currentParseCallback = null;\n        var moduleOverrides = Object.assign({}, Module);\n        var arguments_ = [];\n        var thisProgram = \"./this.program\";\n        var quit_ = /* @__PURE__ */ __name((status, toThrow) => {\n          throw toThrow;\n        }, \"quit_\");\n        var scriptDirectory = \"\";\n        function locateFile(path) {\n          if (Module[\"locateFile\"]) {\n            return Module[\"locateFile\"](path, scriptDirectory);\n          }\n          return scriptDirectory + path;\n        }\n        __name(locateFile, \"locateFile\");\n        var readAsync, readBinary;\n        if (ENVIRONMENT_IS_NODE) {\n          var fs = require(\"fs\");\n          var nodePath = require(\"path\");\n          scriptDirectory = __dirname + \"/\";\n          readBinary = /* @__PURE__ */ __name((filename) => {\n            filename = isFileURI(filename) ? new URL(filename) : filename;\n            var ret = fs.readFileSync(filename);\n            return ret;\n          }, \"readBinary\");\n          readAsync = /* @__PURE__ */ __name(async (filename, binary2 = true) => {\n            filename = isFileURI(filename) ? new URL(filename) : filename;\n            var ret = fs.readFileSync(filename, binary2 ? void 0 : \"utf8\");\n            return ret;\n          }, \"readAsync\");\n          if (!Module[\"thisProgram\"] && process.argv.length > 1) {\n            thisProgram = process.argv[1].replace(/\\\\/g, \"/\");\n          }\n          arguments_ = process.argv.slice(2);\n          quit_ = /* @__PURE__ */ __name((status, toThrow) => {\n            process.exitCode = status;\n            throw toThrow;\n          }, \"quit_\");\n        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n          if (ENVIRONMENT_IS_WORKER) {\n            scriptDirectory = self.location.href;\n          } else if (typeof document != \"undefined\" && document.currentScript) {\n            scriptDirectory = document.currentScript.src;\n          }\n          if (_scriptName) {\n            scriptDirectory = _scriptName;\n          }\n          if (scriptDirectory.startsWith(\"blob:\")) {\n            scriptDirectory = \"\";\n          } else {\n            scriptDirectory = scriptDirectory.slice(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n          }\n          {\n            if (ENVIRONMENT_IS_WORKER) {\n              readBinary = /* @__PURE__ */ __name((url) => {\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"GET\", url, false);\n                xhr.responseType = \"arraybuffer\";\n                xhr.send(null);\n                return new Uint8Array(\n                  /** @type{!ArrayBuffer} */\n                  xhr.response\n                );\n              }, \"readBinary\");\n            }\n            readAsync = /* @__PURE__ */ __name(async (url) => {\n              if (isFileURI(url)) {\n                return new Promise((resolve, reject) => {\n                  var xhr = new XMLHttpRequest();\n                  xhr.open(\"GET\", url, true);\n                  xhr.responseType = \"arraybuffer\";\n                  xhr.onload = () => {\n                    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n                      resolve(xhr.response);\n                      return;\n                    }\n                    reject(xhr.status);\n                  };\n                  xhr.onerror = reject;\n                  xhr.send(null);\n                });\n              }\n              var response = await fetch(url, {\n                credentials: \"same-origin\"\n              });\n              if (response.ok) {\n                return response.arrayBuffer();\n              }\n              throw new Error(response.status + \" : \" + response.url);\n            }, \"readAsync\");\n          }\n        } else {\n        }\n        var out = Module[\"print\"] || console.log.bind(console);\n        var err = Module[\"printErr\"] || console.error.bind(console);\n        Object.assign(Module, moduleOverrides);\n        moduleOverrides = null;\n        if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n        if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n        var dynamicLibraries = Module[\"dynamicLibraries\"] || [];\n        var wasmBinary = Module[\"wasmBinary\"];\n        var wasmMemory;\n        var ABORT = false;\n        var EXITSTATUS;\n        function assert(condition, text) {\n          if (!condition) {\n            abort(text);\n          }\n        }\n        __name(assert, \"assert\");\n        var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;\n        var HEAP_DATA_VIEW;\n        var runtimeInitialized = false;\n        var isFileURI = /* @__PURE__ */ __name((filename) => filename.startsWith(\"file://\"), \"isFileURI\");\n        function updateMemoryViews() {\n          var b = wasmMemory.buffer;\n          Module[\"HEAP_DATA_VIEW\"] = HEAP_DATA_VIEW = new DataView(b);\n          Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n          Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n          Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n          Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n          Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n          Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n          Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n          Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n          Module[\"HEAP64\"] = HEAP64 = new BigInt64Array(b);\n          Module[\"HEAPU64\"] = HEAPU64 = new BigUint64Array(b);\n        }\n        __name(updateMemoryViews, \"updateMemoryViews\");\n        if (Module[\"wasmMemory\"]) {\n          wasmMemory = Module[\"wasmMemory\"];\n        } else {\n          var INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 33554432;\n          wasmMemory = new WebAssembly.Memory({\n            \"initial\": INITIAL_MEMORY / 65536,\n            // In theory we should not need to emit the maximum if we want \"unlimited\"\n            // or 4GB of memory, but VMs error on that atm, see\n            // https://github.com/emscripten-core/emscripten/issues/14130\n            // And in the pthreads case we definitely need to emit a maximum. So\n            // always emit one.\n            \"maximum\": 32768\n          });\n        }\n        updateMemoryViews();\n        var __RELOC_FUNCS__ = [];\n        function preRun() {\n          if (Module[\"preRun\"]) {\n            if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n            while (Module[\"preRun\"].length) {\n              addOnPreRun(Module[\"preRun\"].shift());\n            }\n          }\n          callRuntimeCallbacks(onPreRuns);\n        }\n        __name(preRun, \"preRun\");\n        function initRuntime() {\n          runtimeInitialized = true;\n          callRuntimeCallbacks(__RELOC_FUNCS__);\n          wasmExports[\"__wasm_call_ctors\"]();\n          callRuntimeCallbacks(onPostCtors);\n        }\n        __name(initRuntime, \"initRuntime\");\n        function preMain() {\n        }\n        __name(preMain, \"preMain\");\n        function postRun() {\n          if (Module[\"postRun\"]) {\n            if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n            while (Module[\"postRun\"].length) {\n              addOnPostRun(Module[\"postRun\"].shift());\n            }\n          }\n          callRuntimeCallbacks(onPostRuns);\n        }\n        __name(postRun, \"postRun\");\n        var runDependencies = 0;\n        var dependenciesFulfilled = null;\n        function getUniqueRunDependency(id) {\n          return id;\n        }\n        __name(getUniqueRunDependency, \"getUniqueRunDependency\");\n        function addRunDependency(id) {\n          runDependencies++;\n          Module[\"monitorRunDependencies\"]?.(runDependencies);\n        }\n        __name(addRunDependency, \"addRunDependency\");\n        function removeRunDependency(id) {\n          runDependencies--;\n          Module[\"monitorRunDependencies\"]?.(runDependencies);\n          if (runDependencies == 0) {\n            if (dependenciesFulfilled) {\n              var callback = dependenciesFulfilled;\n              dependenciesFulfilled = null;\n              callback();\n            }\n          }\n        }\n        __name(removeRunDependency, \"removeRunDependency\");\n        function abort(what) {\n          Module[\"onAbort\"]?.(what);\n          what = \"Aborted(\" + what + \")\";\n          err(what);\n          ABORT = true;\n          what += \". Build with -sASSERTIONS for more info.\";\n          var e = new WebAssembly.RuntimeError(what);\n          readyPromiseReject(e);\n          throw e;\n        }\n        __name(abort, \"abort\");\n        var wasmBinaryFile;\n        function findWasmBinary() {\n          return locateFile(\"tree-sitter.wasm\");\n        }\n        __name(findWasmBinary, \"findWasmBinary\");\n        function getBinarySync(file) {\n          if (file == wasmBinaryFile && wasmBinary) {\n            return new Uint8Array(wasmBinary);\n          }\n          if (readBinary) {\n            return readBinary(file);\n          }\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n        __name(getBinarySync, \"getBinarySync\");\n        async function getWasmBinary(binaryFile) {\n          if (!wasmBinary) {\n            try {\n              var response = await readAsync(binaryFile);\n              return new Uint8Array(response);\n            } catch {\n            }\n          }\n          return getBinarySync(binaryFile);\n        }\n        __name(getWasmBinary, \"getWasmBinary\");\n        async function instantiateArrayBuffer(binaryFile, imports) {\n          try {\n            var binary2 = await getWasmBinary(binaryFile);\n            var instance2 = await WebAssembly.instantiate(binary2, imports);\n            return instance2;\n          } catch (reason) {\n            err(`failed to asynchronously prepare wasm: ${reason}`);\n            abort(reason);\n          }\n        }\n        __name(instantiateArrayBuffer, \"instantiateArrayBuffer\");\n        async function instantiateAsync(binary2, binaryFile, imports) {\n          if (!binary2 && typeof WebAssembly.instantiateStreaming == \"function\" && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE) {\n            try {\n              var response = fetch(binaryFile, {\n                credentials: \"same-origin\"\n              });\n              var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);\n              return instantiationResult;\n            } catch (reason) {\n              err(`wasm streaming compile failed: ${reason}`);\n              err(\"falling back to ArrayBuffer instantiation\");\n            }\n          }\n          return instantiateArrayBuffer(binaryFile, imports);\n        }\n        __name(instantiateAsync, \"instantiateAsync\");\n        function getWasmImports() {\n          return {\n            \"env\": wasmImports,\n            \"wasi_snapshot_preview1\": wasmImports,\n            \"GOT.mem\": new Proxy(wasmImports, GOTHandler),\n            \"GOT.func\": new Proxy(wasmImports, GOTHandler)\n          };\n        }\n        __name(getWasmImports, \"getWasmImports\");\n        async function createWasm() {\n          function receiveInstance(instance2, module2) {\n            wasmExports = instance2.exports;\n            wasmExports = relocateExports(wasmExports, 1024);\n            var metadata2 = getDylinkMetadata(module2);\n            if (metadata2.neededDynlibs) {\n              dynamicLibraries = metadata2.neededDynlibs.concat(dynamicLibraries);\n            }\n            mergeLibSymbols(wasmExports, \"main\");\n            LDSO.init();\n            loadDylibs();\n            __RELOC_FUNCS__.push(wasmExports[\"__wasm_apply_data_relocs\"]);\n            removeRunDependency(\"wasm-instantiate\");\n            return wasmExports;\n          }\n          __name(receiveInstance, \"receiveInstance\");\n          addRunDependency(\"wasm-instantiate\");\n          function receiveInstantiationResult(result2) {\n            return receiveInstance(result2[\"instance\"], result2[\"module\"]);\n          }\n          __name(receiveInstantiationResult, \"receiveInstantiationResult\");\n          var info2 = getWasmImports();\n          if (Module[\"instantiateWasm\"]) {\n            return new Promise((resolve, reject) => {\n              Module[\"instantiateWasm\"](info2, (mod, inst) => {\n                receiveInstance(mod, inst);\n                resolve(mod.exports);\n              });\n            });\n          }\n          wasmBinaryFile ??= findWasmBinary();\n          try {\n            var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info2);\n            var exports2 = receiveInstantiationResult(result);\n            return exports2;\n          } catch (e) {\n            readyPromiseReject(e);\n            return Promise.reject(e);\n          }\n        }\n        __name(createWasm, \"createWasm\");\n        var ASM_CONSTS = {};\n        class ExitStatus {\n          static {\n            __name(this, \"ExitStatus\");\n          }\n          name = \"ExitStatus\";\n          constructor(status) {\n            this.message = `Program terminated with exit(${status})`;\n            this.status = status;\n          }\n        }\n        var GOT = {};\n        var currentModuleWeakSymbols = /* @__PURE__ */ new Set([]);\n        var GOTHandler = {\n          get(obj, symName) {\n            var rtn = GOT[symName];\n            if (!rtn) {\n              rtn = GOT[symName] = new WebAssembly.Global({\n                \"value\": \"i32\",\n                \"mutable\": true\n              });\n            }\n            if (!currentModuleWeakSymbols.has(symName)) {\n              rtn.required = true;\n            }\n            return rtn;\n          }\n        };\n        var LE_HEAP_LOAD_F32 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getFloat32(byteOffset, true), \"LE_HEAP_LOAD_F32\");\n        var LE_HEAP_LOAD_F64 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getFloat64(byteOffset, true), \"LE_HEAP_LOAD_F64\");\n        var LE_HEAP_LOAD_I16 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getInt16(byteOffset, true), \"LE_HEAP_LOAD_I16\");\n        var LE_HEAP_LOAD_I32 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getInt32(byteOffset, true), \"LE_HEAP_LOAD_I32\");\n        var LE_HEAP_LOAD_U16 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getUint16(byteOffset, true), \"LE_HEAP_LOAD_U16\");\n        var LE_HEAP_LOAD_U32 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getUint32(byteOffset, true), \"LE_HEAP_LOAD_U32\");\n        var LE_HEAP_STORE_F32 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setFloat32(byteOffset, value, true), \"LE_HEAP_STORE_F32\");\n        var LE_HEAP_STORE_F64 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setFloat64(byteOffset, value, true), \"LE_HEAP_STORE_F64\");\n        var LE_HEAP_STORE_I16 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setInt16(byteOffset, value, true), \"LE_HEAP_STORE_I16\");\n        var LE_HEAP_STORE_I32 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setInt32(byteOffset, value, true), \"LE_HEAP_STORE_I32\");\n        var LE_HEAP_STORE_U16 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setUint16(byteOffset, value, true), \"LE_HEAP_STORE_U16\");\n        var LE_HEAP_STORE_U32 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setUint32(byteOffset, value, true), \"LE_HEAP_STORE_U32\");\n        var callRuntimeCallbacks = /* @__PURE__ */ __name((callbacks) => {\n          while (callbacks.length > 0) {\n            callbacks.shift()(Module);\n          }\n        }, \"callRuntimeCallbacks\");\n        var onPostRuns = [];\n        var addOnPostRun = /* @__PURE__ */ __name((cb) => onPostRuns.unshift(cb), \"addOnPostRun\");\n        var onPreRuns = [];\n        var addOnPreRun = /* @__PURE__ */ __name((cb) => onPreRuns.unshift(cb), \"addOnPreRun\");\n        var UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder() : void 0;\n        var UTF8ArrayToString = /* @__PURE__ */ __name((heapOrArray, idx = 0, maxBytesToRead = NaN) => {\n          var endIdx = idx + maxBytesToRead;\n          var endPtr = idx;\n          while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n          if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n          }\n          var str = \"\";\n          while (idx < endPtr) {\n            var u0 = heapOrArray[idx++];\n            if (!(u0 & 128)) {\n              str += String.fromCharCode(u0);\n              continue;\n            }\n            var u1 = heapOrArray[idx++] & 63;\n            if ((u0 & 224) == 192) {\n              str += String.fromCharCode((u0 & 31) << 6 | u1);\n              continue;\n            }\n            var u2 = heapOrArray[idx++] & 63;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n            }\n            if (u0 < 65536) {\n              str += String.fromCharCode(u0);\n            } else {\n              var ch = u0 - 65536;\n              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n            }\n          }\n          return str;\n        }, \"UTF8ArrayToString\");\n        var getDylinkMetadata = /* @__PURE__ */ __name((binary2) => {\n          var offset = 0;\n          var end = 0;\n          function getU8() {\n            return binary2[offset++];\n          }\n          __name(getU8, \"getU8\");\n          function getLEB() {\n            var ret = 0;\n            var mul = 1;\n            while (1) {\n              var byte = binary2[offset++];\n              ret += (byte & 127) * mul;\n              mul *= 128;\n              if (!(byte & 128)) break;\n            }\n            return ret;\n          }\n          __name(getLEB, \"getLEB\");\n          function getString() {\n            var len = getLEB();\n            offset += len;\n            return UTF8ArrayToString(binary2, offset - len, len);\n          }\n          __name(getString, \"getString\");\n          function failIf(condition, message) {\n            if (condition) throw new Error(message);\n          }\n          __name(failIf, \"failIf\");\n          var name2 = \"dylink.0\";\n          if (binary2 instanceof WebAssembly.Module) {\n            var dylinkSection = WebAssembly.Module.customSections(binary2, name2);\n            if (dylinkSection.length === 0) {\n              name2 = \"dylink\";\n              dylinkSection = WebAssembly.Module.customSections(binary2, name2);\n            }\n            failIf(dylinkSection.length === 0, \"need dylink section\");\n            binary2 = new Uint8Array(dylinkSection[0]);\n            end = binary2.length;\n          } else {\n            var int32View = new Uint32Array(new Uint8Array(binary2.subarray(0, 24)).buffer);\n            var magicNumberFound = int32View[0] == 1836278016 || int32View[0] == 6386541;\n            failIf(!magicNumberFound, \"need to see wasm magic number\");\n            failIf(binary2[8] !== 0, \"need the dylink section to be first\");\n            offset = 9;\n            var section_size = getLEB();\n            end = offset + section_size;\n            name2 = getString();\n          }\n          var customSection = {\n            neededDynlibs: [],\n            tlsExports: /* @__PURE__ */ new Set(),\n            weakImports: /* @__PURE__ */ new Set()\n          };\n          if (name2 == \"dylink\") {\n            customSection.memorySize = getLEB();\n            customSection.memoryAlign = getLEB();\n            customSection.tableSize = getLEB();\n            customSection.tableAlign = getLEB();\n            var neededDynlibsCount = getLEB();\n            for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {\n              var libname = getString();\n              customSection.neededDynlibs.push(libname);\n            }\n          } else {\n            failIf(name2 !== \"dylink.0\");\n            var WASM_DYLINK_MEM_INFO = 1;\n            var WASM_DYLINK_NEEDED = 2;\n            var WASM_DYLINK_EXPORT_INFO = 3;\n            var WASM_DYLINK_IMPORT_INFO = 4;\n            var WASM_SYMBOL_TLS = 256;\n            var WASM_SYMBOL_BINDING_MASK = 3;\n            var WASM_SYMBOL_BINDING_WEAK = 1;\n            while (offset < end) {\n              var subsectionType = getU8();\n              var subsectionSize = getLEB();\n              if (subsectionType === WASM_DYLINK_MEM_INFO) {\n                customSection.memorySize = getLEB();\n                customSection.memoryAlign = getLEB();\n                customSection.tableSize = getLEB();\n                customSection.tableAlign = getLEB();\n              } else if (subsectionType === WASM_DYLINK_NEEDED) {\n                var neededDynlibsCount = getLEB();\n                for (var i2 = 0; i2 < neededDynlibsCount; ++i2) {\n                  libname = getString();\n                  customSection.neededDynlibs.push(libname);\n                }\n              } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {\n                var count = getLEB();\n                while (count--) {\n                  var symname = getString();\n                  var flags2 = getLEB();\n                  if (flags2 & WASM_SYMBOL_TLS) {\n                    customSection.tlsExports.add(symname);\n                  }\n                }\n              } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {\n                var count = getLEB();\n                while (count--) {\n                  var modname = getString();\n                  var symname = getString();\n                  var flags2 = getLEB();\n                  if ((flags2 & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {\n                    customSection.weakImports.add(symname);\n                  }\n                }\n              } else {\n                offset += subsectionSize;\n              }\n            }\n          }\n          return customSection;\n        }, \"getDylinkMetadata\");\n        function getValue(ptr, type = \"i8\") {\n          if (type.endsWith(\"*\")) type = \"*\";\n          switch (type) {\n            case \"i1\":\n              return HEAP8[ptr];\n            case \"i8\":\n              return HEAP8[ptr];\n            case \"i16\":\n              return LE_HEAP_LOAD_I16((ptr >> 1) * 2);\n            case \"i32\":\n              return LE_HEAP_LOAD_I32((ptr >> 2) * 4);\n            case \"i64\":\n              return HEAP64[ptr >> 3];\n            case \"float\":\n              return LE_HEAP_LOAD_F32((ptr >> 2) * 4);\n            case \"double\":\n              return LE_HEAP_LOAD_F64((ptr >> 3) * 8);\n            case \"*\":\n              return LE_HEAP_LOAD_U32((ptr >> 2) * 4);\n            default:\n              abort(`invalid type for getValue: ${type}`);\n          }\n        }\n        __name(getValue, \"getValue\");\n        var newDSO = /* @__PURE__ */ __name((name2, handle2, syms) => {\n          var dso = {\n            refcount: Infinity,\n            name: name2,\n            exports: syms,\n            global: true\n          };\n          LDSO.loadedLibsByName[name2] = dso;\n          if (handle2 != void 0) {\n            LDSO.loadedLibsByHandle[handle2] = dso;\n          }\n          return dso;\n        }, \"newDSO\");\n        var LDSO = {\n          loadedLibsByName: {},\n          loadedLibsByHandle: {},\n          init() {\n            newDSO(\"__main__\", 0, wasmImports);\n          }\n        };\n        var ___heap_base = 78224;\n        var alignMemory = /* @__PURE__ */ __name((size, alignment) => Math.ceil(size / alignment) * alignment, \"alignMemory\");\n        var getMemory = /* @__PURE__ */ __name((size) => {\n          if (runtimeInitialized) {\n            return _calloc(size, 1);\n          }\n          var ret = ___heap_base;\n          var end = ret + alignMemory(size, 16);\n          ___heap_base = end;\n          GOT[\"__heap_base\"].value = end;\n          return ret;\n        }, \"getMemory\");\n        var isInternalSym = /* @__PURE__ */ __name((symName) => [\"__cpp_exception\", \"__c_longjmp\", \"__wasm_apply_data_relocs\", \"__dso_handle\", \"__tls_size\", \"__tls_align\", \"__set_stack_limits\", \"_emscripten_tls_init\", \"__wasm_init_tls\", \"__wasm_call_ctors\", \"__start_em_asm\", \"__stop_em_asm\", \"__start_em_js\", \"__stop_em_js\"].includes(symName) || symName.startsWith(\"__em_js__\"), \"isInternalSym\");\n        var uleb128Encode = /* @__PURE__ */ __name((n, target) => {\n          if (n < 128) {\n            target.push(n);\n          } else {\n            target.push(n % 128 | 128, n >> 7);\n          }\n        }, \"uleb128Encode\");\n        var sigToWasmTypes = /* @__PURE__ */ __name((sig) => {\n          var typeNames = {\n            \"i\": \"i32\",\n            \"j\": \"i64\",\n            \"f\": \"f32\",\n            \"d\": \"f64\",\n            \"e\": \"externref\",\n            \"p\": \"i32\"\n          };\n          var type = {\n            parameters: [],\n            results: sig[0] == \"v\" ? [] : [typeNames[sig[0]]]\n          };\n          for (var i2 = 1; i2 < sig.length; ++i2) {\n            type.parameters.push(typeNames[sig[i2]]);\n          }\n          return type;\n        }, \"sigToWasmTypes\");\n        var generateFuncType = /* @__PURE__ */ __name((sig, target) => {\n          var sigRet = sig.slice(0, 1);\n          var sigParam = sig.slice(1);\n          var typeCodes = {\n            \"i\": 127,\n            // i32\n            \"p\": 127,\n            // i32\n            \"j\": 126,\n            // i64\n            \"f\": 125,\n            // f32\n            \"d\": 124,\n            // f64\n            \"e\": 111\n          };\n          target.push(96);\n          uleb128Encode(sigParam.length, target);\n          for (var i2 = 0; i2 < sigParam.length; ++i2) {\n            target.push(typeCodes[sigParam[i2]]);\n          }\n          if (sigRet == \"v\") {\n            target.push(0);\n          } else {\n            target.push(1, typeCodes[sigRet]);\n          }\n        }, \"generateFuncType\");\n        var convertJsFunctionToWasm = /* @__PURE__ */ __name((func2, sig) => {\n          if (typeof WebAssembly.Function == \"function\") {\n            return new WebAssembly.Function(sigToWasmTypes(sig), func2);\n          }\n          var typeSectionBody = [1];\n          generateFuncType(sig, typeSectionBody);\n          var bytes = [\n            0,\n            97,\n            115,\n            109,\n            // magic (\"\\0asm\")\n            1,\n            0,\n            0,\n            0,\n            // version: 1\n            1\n          ];\n          uleb128Encode(typeSectionBody.length, bytes);\n          bytes.push(...typeSectionBody);\n          bytes.push(\n            2,\n            7,\n            // import section\n            // (import \"e\" \"f\" (func 0 (type 0)))\n            1,\n            1,\n            101,\n            1,\n            102,\n            0,\n            0,\n            7,\n            5,\n            // export section\n            // (export \"f\" (func 0 (type 0)))\n            1,\n            1,\n            102,\n            0,\n            0\n          );\n          var module2 = new WebAssembly.Module(new Uint8Array(bytes));\n          var instance2 = new WebAssembly.Instance(module2, {\n            \"e\": {\n              \"f\": func2\n            }\n          });\n          var wrappedFunc = instance2.exports[\"f\"];\n          return wrappedFunc;\n        }, \"convertJsFunctionToWasm\");\n        var wasmTableMirror = [];\n        var wasmTable = new WebAssembly.Table({\n          \"initial\": 31,\n          \"element\": \"anyfunc\"\n        });\n        var getWasmTableEntry = /* @__PURE__ */ __name((funcPtr) => {\n          var func2 = wasmTableMirror[funcPtr];\n          if (!func2) {\n            if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n            wasmTableMirror[funcPtr] = func2 = wasmTable.get(funcPtr);\n          }\n          return func2;\n        }, \"getWasmTableEntry\");\n        var updateTableMap = /* @__PURE__ */ __name((offset, count) => {\n          if (functionsInTableMap) {\n            for (var i2 = offset; i2 < offset + count; i2++) {\n              var item = getWasmTableEntry(i2);\n              if (item) {\n                functionsInTableMap.set(item, i2);\n              }\n            }\n          }\n        }, \"updateTableMap\");\n        var functionsInTableMap;\n        var getFunctionAddress = /* @__PURE__ */ __name((func2) => {\n          if (!functionsInTableMap) {\n            functionsInTableMap = /* @__PURE__ */ new WeakMap();\n            updateTableMap(0, wasmTable.length);\n          }\n          return functionsInTableMap.get(func2) || 0;\n        }, \"getFunctionAddress\");\n        var freeTableIndexes = [];\n        var getEmptyTableSlot = /* @__PURE__ */ __name(() => {\n          if (freeTableIndexes.length) {\n            return freeTableIndexes.pop();\n          }\n          try {\n            wasmTable.grow(1);\n          } catch (err2) {\n            if (!(err2 instanceof RangeError)) {\n              throw err2;\n            }\n            throw \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\";\n          }\n          return wasmTable.length - 1;\n        }, \"getEmptyTableSlot\");\n        var setWasmTableEntry = /* @__PURE__ */ __name((idx, func2) => {\n          wasmTable.set(idx, func2);\n          wasmTableMirror[idx] = wasmTable.get(idx);\n        }, \"setWasmTableEntry\");\n        var addFunction = /* @__PURE__ */ __name((func2, sig) => {\n          var rtn = getFunctionAddress(func2);\n          if (rtn) {\n            return rtn;\n          }\n          var ret = getEmptyTableSlot();\n          try {\n            setWasmTableEntry(ret, func2);\n          } catch (err2) {\n            if (!(err2 instanceof TypeError)) {\n              throw err2;\n            }\n            var wrapped = convertJsFunctionToWasm(func2, sig);\n            setWasmTableEntry(ret, wrapped);\n          }\n          functionsInTableMap.set(func2, ret);\n          return ret;\n        }, \"addFunction\");\n        var updateGOT = /* @__PURE__ */ __name((exports2, replace) => {\n          for (var symName in exports2) {\n            if (isInternalSym(symName)) {\n              continue;\n            }\n            var value = exports2[symName];\n            GOT[symName] ||= new WebAssembly.Global({\n              \"value\": \"i32\",\n              \"mutable\": true\n            });\n            if (replace || GOT[symName].value == 0) {\n              if (typeof value == \"function\") {\n                GOT[symName].value = addFunction(value);\n              } else if (typeof value == \"number\") {\n                GOT[symName].value = value;\n              } else {\n                err(`unhandled export type for '${symName}': ${typeof value}`);\n              }\n            }\n          }\n        }, \"updateGOT\");\n        var relocateExports = /* @__PURE__ */ __name((exports2, memoryBase2, replace) => {\n          var relocated = {};\n          for (var e in exports2) {\n            var value = exports2[e];\n            if (typeof value == \"object\") {\n              value = value.value;\n            }\n            if (typeof value == \"number\") {\n              value += memoryBase2;\n            }\n            relocated[e] = value;\n          }\n          updateGOT(relocated, replace);\n          return relocated;\n        }, \"relocateExports\");\n        var isSymbolDefined = /* @__PURE__ */ __name((symName) => {\n          var existing = wasmImports[symName];\n          if (!existing || existing.stub) {\n            return false;\n          }\n          return true;\n        }, \"isSymbolDefined\");\n        var dynCall = /* @__PURE__ */ __name((sig, ptr, args2 = []) => {\n          var rtn = getWasmTableEntry(ptr)(...args2);\n          return rtn;\n        }, \"dynCall\");\n        var stackSave = /* @__PURE__ */ __name(() => _emscripten_stack_get_current(), \"stackSave\");\n        var stackRestore = /* @__PURE__ */ __name((val) => __emscripten_stack_restore(val), \"stackRestore\");\n        var createInvokeFunction = /* @__PURE__ */ __name((sig) => (ptr, ...args2) => {\n          var sp = stackSave();\n          try {\n            return dynCall(sig, ptr, args2);\n          } catch (e) {\n            stackRestore(sp);\n            if (e !== e + 0) throw e;\n            _setThrew(1, 0);\n            if (sig[0] == \"j\") return 0n;\n          }\n        }, \"createInvokeFunction\");\n        var resolveGlobalSymbol = /* @__PURE__ */ __name((symName, direct = false) => {\n          var sym;\n          if (isSymbolDefined(symName)) {\n            sym = wasmImports[symName];\n          } else if (symName.startsWith(\"invoke_\")) {\n            sym = wasmImports[symName] = createInvokeFunction(symName.split(\"_\")[1]);\n          }\n          return {\n            sym,\n            name: symName\n          };\n        }, \"resolveGlobalSymbol\");\n        var onPostCtors = [];\n        var addOnPostCtor = /* @__PURE__ */ __name((cb) => onPostCtors.unshift(cb), \"addOnPostCtor\");\n        var UTF8ToString = /* @__PURE__ */ __name((ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\", \"UTF8ToString\");\n        var loadWebAssemblyModule = /* @__PURE__ */ __name((binary, flags, libName, localScope, handle) => {\n          var metadata = getDylinkMetadata(binary);\n          currentModuleWeakSymbols = metadata.weakImports;\n          function loadModule() {\n            var memAlign = Math.pow(2, metadata.memoryAlign);\n            var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0;\n            var tableBase = metadata.tableSize ? wasmTable.length : 0;\n            if (handle) {\n              HEAP8[handle + 8] = 1;\n              LE_HEAP_STORE_U32((handle + 12 >> 2) * 4, memoryBase);\n              LE_HEAP_STORE_I32((handle + 16 >> 2) * 4, metadata.memorySize);\n              LE_HEAP_STORE_U32((handle + 20 >> 2) * 4, tableBase);\n              LE_HEAP_STORE_I32((handle + 24 >> 2) * 4, metadata.tableSize);\n            }\n            if (metadata.tableSize) {\n              wasmTable.grow(metadata.tableSize);\n            }\n            var moduleExports;\n            function resolveSymbol(sym) {\n              var resolved = resolveGlobalSymbol(sym).sym;\n              if (!resolved && localScope) {\n                resolved = localScope[sym];\n              }\n              if (!resolved) {\n                resolved = moduleExports[sym];\n              }\n              return resolved;\n            }\n            __name(resolveSymbol, \"resolveSymbol\");\n            var proxyHandler = {\n              get(stubs, prop) {\n                switch (prop) {\n                  case \"__memory_base\":\n                    return memoryBase;\n                  case \"__table_base\":\n                    return tableBase;\n                }\n                if (prop in wasmImports && !wasmImports[prop].stub) {\n                  var res = wasmImports[prop];\n                  return res;\n                }\n                if (!(prop in stubs)) {\n                  var resolved;\n                  stubs[prop] = (...args2) => {\n                    resolved ||= resolveSymbol(prop);\n                    return resolved(...args2);\n                  };\n                }\n                return stubs[prop];\n              }\n            };\n            var proxy = new Proxy({}, proxyHandler);\n            var info = {\n              \"GOT.mem\": new Proxy({}, GOTHandler),\n              \"GOT.func\": new Proxy({}, GOTHandler),\n              \"env\": proxy,\n              \"wasi_snapshot_preview1\": proxy\n            };\n            function postInstantiation(module, instance) {\n              updateTableMap(tableBase, metadata.tableSize);\n              moduleExports = relocateExports(instance.exports, memoryBase);\n              if (!flags.allowUndefined) {\n                reportUndefinedSymbols();\n              }\n              function addEmAsm(addr, body) {\n                var args = [];\n                var arity = 0;\n                for (; arity < 16; arity++) {\n                  if (body.indexOf(\"$\" + arity) != -1) {\n                    args.push(\"$\" + arity);\n                  } else {\n                    break;\n                  }\n                }\n                args = args.join(\",\");\n                var func = `(${args}) => { ${body} };`;\n                ASM_CONSTS[start] = eval(func);\n              }\n              __name(addEmAsm, \"addEmAsm\");\n              if (\"__start_em_asm\" in moduleExports) {\n                var start = moduleExports[\"__start_em_asm\"];\n                var stop = moduleExports[\"__stop_em_asm\"];\n                while (start < stop) {\n                  var jsString = UTF8ToString(start);\n                  addEmAsm(start, jsString);\n                  start = HEAPU8.indexOf(0, start) + 1;\n                }\n              }\n              function addEmJs(name, cSig, body) {\n                var jsArgs = [];\n                cSig = cSig.slice(1, -1);\n                if (cSig != \"void\") {\n                  cSig = cSig.split(\",\");\n                  for (var i in cSig) {\n                    var jsArg = cSig[i].split(\" \").pop();\n                    jsArgs.push(jsArg.replace(\"*\", \"\"));\n                  }\n                }\n                var func = `(${jsArgs}) => ${body};`;\n                moduleExports[name] = eval(func);\n              }\n              __name(addEmJs, \"addEmJs\");\n              for (var name in moduleExports) {\n                if (name.startsWith(\"__em_js__\")) {\n                  var start = moduleExports[name];\n                  var jsString = UTF8ToString(start);\n                  var parts = jsString.split(\"<::>\");\n                  addEmJs(name.replace(\"__em_js__\", \"\"), parts[0], parts[1]);\n                  delete moduleExports[name];\n                }\n              }\n              var applyRelocs = moduleExports[\"__wasm_apply_data_relocs\"];\n              if (applyRelocs) {\n                if (runtimeInitialized) {\n                  applyRelocs();\n                } else {\n                  __RELOC_FUNCS__.push(applyRelocs);\n                }\n              }\n              var init = moduleExports[\"__wasm_call_ctors\"];\n              if (init) {\n                if (runtimeInitialized) {\n                  init();\n                } else {\n                  addOnPostCtor(init);\n                }\n              }\n              return moduleExports;\n            }\n            __name(postInstantiation, \"postInstantiation\");\n            if (flags.loadAsync) {\n              if (binary instanceof WebAssembly.Module) {\n                var instance = new WebAssembly.Instance(binary, info);\n                return Promise.resolve(postInstantiation(binary, instance));\n              }\n              return WebAssembly.instantiate(binary, info).then((result) => postInstantiation(result.module, result.instance));\n            }\n            var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);\n            var instance = new WebAssembly.Instance(module, info);\n            return postInstantiation(module, instance);\n          }\n          __name(loadModule, \"loadModule\");\n          if (flags.loadAsync) {\n            return metadata.neededDynlibs.reduce((chain, dynNeeded) => chain.then(() => loadDynamicLibrary(dynNeeded, flags, localScope)), Promise.resolve()).then(loadModule);\n          }\n          metadata.neededDynlibs.forEach((needed) => loadDynamicLibrary(needed, flags, localScope));\n          return loadModule();\n        }, \"loadWebAssemblyModule\");\n        var mergeLibSymbols = /* @__PURE__ */ __name((exports2, libName2) => {\n          for (var [sym, exp] of Object.entries(exports2)) {\n            const setImport = /* @__PURE__ */ __name((target) => {\n              if (!isSymbolDefined(target)) {\n                wasmImports[target] = exp;\n              }\n            }, \"setImport\");\n            setImport(sym);\n            const main_alias = \"__main_argc_argv\";\n            if (sym == \"main\") {\n              setImport(main_alias);\n            }\n            if (sym == main_alias) {\n              setImport(\"main\");\n            }\n          }\n        }, \"mergeLibSymbols\");\n        var asyncLoad = /* @__PURE__ */ __name(async (url) => {\n          var arrayBuffer = await readAsync(url);\n          return new Uint8Array(arrayBuffer);\n        }, \"asyncLoad\");\n        function loadDynamicLibrary(libName2, flags2 = {\n          global: true,\n          nodelete: true\n        }, localScope2, handle2) {\n          var dso = LDSO.loadedLibsByName[libName2];\n          if (dso) {\n            if (!flags2.global) {\n              if (localScope2) {\n                Object.assign(localScope2, dso.exports);\n              }\n            } else if (!dso.global) {\n              dso.global = true;\n              mergeLibSymbols(dso.exports, libName2);\n            }\n            if (flags2.nodelete && dso.refcount !== Infinity) {\n              dso.refcount = Infinity;\n            }\n            dso.refcount++;\n            if (handle2) {\n              LDSO.loadedLibsByHandle[handle2] = dso;\n            }\n            return flags2.loadAsync ? Promise.resolve(true) : true;\n          }\n          dso = newDSO(libName2, handle2, \"loading\");\n          dso.refcount = flags2.nodelete ? Infinity : 1;\n          dso.global = flags2.global;\n          function loadLibData() {\n            if (handle2) {\n              var data = LE_HEAP_LOAD_U32((handle2 + 28 >> 2) * 4);\n              var dataSize = LE_HEAP_LOAD_U32((handle2 + 32 >> 2) * 4);\n              if (data && dataSize) {\n                var libData = HEAP8.slice(data, data + dataSize);\n                return flags2.loadAsync ? Promise.resolve(libData) : libData;\n              }\n            }\n            var libFile = locateFile(libName2);\n            if (flags2.loadAsync) {\n              return asyncLoad(libFile);\n            }\n            if (!readBinary) {\n              throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);\n            }\n            return readBinary(libFile);\n          }\n          __name(loadLibData, \"loadLibData\");\n          function getExports() {\n            if (flags2.loadAsync) {\n              return loadLibData().then((libData) => loadWebAssemblyModule(libData, flags2, libName2, localScope2, handle2));\n            }\n            return loadWebAssemblyModule(loadLibData(), flags2, libName2, localScope2, handle2);\n          }\n          __name(getExports, \"getExports\");\n          function moduleLoaded(exports2) {\n            if (dso.global) {\n              mergeLibSymbols(exports2, libName2);\n            } else if (localScope2) {\n              Object.assign(localScope2, exports2);\n            }\n            dso.exports = exports2;\n          }\n          __name(moduleLoaded, \"moduleLoaded\");\n          if (flags2.loadAsync) {\n            return getExports().then((exports2) => {\n              moduleLoaded(exports2);\n              return true;\n            });\n          }\n          moduleLoaded(getExports());\n          return true;\n        }\n        __name(loadDynamicLibrary, \"loadDynamicLibrary\");\n        var reportUndefinedSymbols = /* @__PURE__ */ __name(() => {\n          for (var [symName, entry] of Object.entries(GOT)) {\n            if (entry.value == 0) {\n              var value = resolveGlobalSymbol(symName, true).sym;\n              if (!value && !entry.required) {\n                continue;\n              }\n              if (typeof value == \"function\") {\n                entry.value = addFunction(value, value.sig);\n              } else if (typeof value == \"number\") {\n                entry.value = value;\n              } else {\n                throw new Error(`bad export type for '${symName}': ${typeof value}`);\n              }\n            }\n          }\n        }, \"reportUndefinedSymbols\");\n        var loadDylibs = /* @__PURE__ */ __name(() => {\n          if (!dynamicLibraries.length) {\n            reportUndefinedSymbols();\n            return;\n          }\n          addRunDependency(\"loadDylibs\");\n          dynamicLibraries.reduce((chain, lib) => chain.then(() => loadDynamicLibrary(lib, {\n            loadAsync: true,\n            global: true,\n            nodelete: true,\n            allowUndefined: true\n          })), Promise.resolve()).then(() => {\n            reportUndefinedSymbols();\n            removeRunDependency(\"loadDylibs\");\n          });\n        }, \"loadDylibs\");\n        var noExitRuntime = Module[\"noExitRuntime\"] || true;\n        function setValue(ptr, value, type = \"i8\") {\n          if (type.endsWith(\"*\")) type = \"*\";\n          switch (type) {\n            case \"i1\":\n              HEAP8[ptr] = value;\n              break;\n            case \"i8\":\n              HEAP8[ptr] = value;\n              break;\n            case \"i16\":\n              LE_HEAP_STORE_I16((ptr >> 1) * 2, value);\n              break;\n            case \"i32\":\n              LE_HEAP_STORE_I32((ptr >> 2) * 4, value);\n              break;\n            case \"i64\":\n              HEAP64[ptr >> 3] = BigInt(value);\n              break;\n            case \"float\":\n              LE_HEAP_STORE_F32((ptr >> 2) * 4, value);\n              break;\n            case \"double\":\n              LE_HEAP_STORE_F64((ptr >> 3) * 8, value);\n              break;\n            case \"*\":\n              LE_HEAP_STORE_U32((ptr >> 2) * 4, value);\n              break;\n            default:\n              abort(`invalid type for setValue: ${type}`);\n          }\n        }\n        __name(setValue, \"setValue\");\n        var ___memory_base = new WebAssembly.Global({\n          \"value\": \"i32\",\n          \"mutable\": false\n        }, 1024);\n        var ___stack_pointer = new WebAssembly.Global({\n          \"value\": \"i32\",\n          \"mutable\": true\n        }, 78224);\n        var ___table_base = new WebAssembly.Global({\n          \"value\": \"i32\",\n          \"mutable\": false\n        }, 1);\n        var __abort_js = /* @__PURE__ */ __name(() => abort(\"\"), \"__abort_js\");\n        __abort_js.sig = \"v\";\n        var _emscripten_get_now = /* @__PURE__ */ __name(() => performance.now(), \"_emscripten_get_now\");\n        _emscripten_get_now.sig = \"d\";\n        var _emscripten_date_now = /* @__PURE__ */ __name(() => Date.now(), \"_emscripten_date_now\");\n        _emscripten_date_now.sig = \"d\";\n        var nowIsMonotonic = 1;\n        var checkWasiClock = /* @__PURE__ */ __name((clock_id) => clock_id >= 0 && clock_id <= 3, \"checkWasiClock\");\n        var INT53_MAX = 9007199254740992;\n        var INT53_MIN = -9007199254740992;\n        var bigintToI53Checked = /* @__PURE__ */ __name((num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num), \"bigintToI53Checked\");\n        function _clock_time_get(clk_id, ignored_precision, ptime) {\n          ignored_precision = bigintToI53Checked(ignored_precision);\n          if (!checkWasiClock(clk_id)) {\n            return 28;\n          }\n          var now;\n          if (clk_id === 0) {\n            now = _emscripten_date_now();\n          } else if (nowIsMonotonic) {\n            now = _emscripten_get_now();\n          } else {\n            return 52;\n          }\n          var nsec = Math.round(now * 1e3 * 1e3);\n          HEAP64[ptime >> 3] = BigInt(nsec);\n          return 0;\n        }\n        __name(_clock_time_get, \"_clock_time_get\");\n        _clock_time_get.sig = \"iijp\";\n        var getHeapMax = /* @__PURE__ */ __name(() => (\n          // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\n          // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\n          // for any code that deals with heap sizes, which would require special\n          // casing all heap size related code to treat 0 specially.\n          2147483648\n        ), \"getHeapMax\");\n        var growMemory = /* @__PURE__ */ __name((size) => {\n          var b = wasmMemory.buffer;\n          var pages = (size - b.byteLength + 65535) / 65536 | 0;\n          try {\n            wasmMemory.grow(pages);\n            updateMemoryViews();\n            return 1;\n          } catch (e) {\n          }\n        }, \"growMemory\");\n        var _emscripten_resize_heap = /* @__PURE__ */ __name((requestedSize) => {\n          var oldSize = HEAPU8.length;\n          requestedSize >>>= 0;\n          var maxHeapSize = getHeapMax();\n          if (requestedSize > maxHeapSize) {\n            return false;\n          }\n          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n            var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));\n            var replacement = growMemory(newSize);\n            if (replacement) {\n              return true;\n            }\n          }\n          return false;\n        }, \"_emscripten_resize_heap\");\n        _emscripten_resize_heap.sig = \"ip\";\n        var _fd_close = /* @__PURE__ */ __name((fd) => 52, \"_fd_close\");\n        _fd_close.sig = \"ii\";\n        function _fd_seek(fd, offset, whence, newOffset) {\n          offset = bigintToI53Checked(offset);\n          return 70;\n        }\n        __name(_fd_seek, \"_fd_seek\");\n        _fd_seek.sig = \"iijip\";\n        var printCharBuffers = [null, [], []];\n        var printChar = /* @__PURE__ */ __name((stream, curr) => {\n          var buffer = printCharBuffers[stream];\n          if (curr === 0 || curr === 10) {\n            (stream === 1 ? out : err)(UTF8ArrayToString(buffer));\n            buffer.length = 0;\n          } else {\n            buffer.push(curr);\n          }\n        }, \"printChar\");\n        var flush_NO_FILESYSTEM = /* @__PURE__ */ __name(() => {\n          if (printCharBuffers[1].length) printChar(1, 10);\n          if (printCharBuffers[2].length) printChar(2, 10);\n        }, \"flush_NO_FILESYSTEM\");\n        var SYSCALLS = {\n          varargs: void 0,\n          getStr(ptr) {\n            var ret = UTF8ToString(ptr);\n            return ret;\n          }\n        };\n        var _fd_write = /* @__PURE__ */ __name((fd, iov, iovcnt, pnum) => {\n          var num = 0;\n          for (var i2 = 0; i2 < iovcnt; i2++) {\n            var ptr = LE_HEAP_LOAD_U32((iov >> 2) * 4);\n            var len = LE_HEAP_LOAD_U32((iov + 4 >> 2) * 4);\n            iov += 8;\n            for (var j = 0; j < len; j++) {\n              printChar(fd, HEAPU8[ptr + j]);\n            }\n            num += len;\n          }\n          LE_HEAP_STORE_U32((pnum >> 2) * 4, num);\n          return 0;\n        }, \"_fd_write\");\n        _fd_write.sig = \"iippp\";\n        function _tree_sitter_log_callback(isLexMessage, messageAddress) {\n          if (Module.currentLogCallback) {\n            const message = UTF8ToString(messageAddress);\n            Module.currentLogCallback(message, isLexMessage !== 0);\n          }\n        }\n        __name(_tree_sitter_log_callback, \"_tree_sitter_log_callback\");\n        function _tree_sitter_parse_callback(inputBufferAddress, index, row, column, lengthAddress) {\n          const INPUT_BUFFER_SIZE = 10 * 1024;\n          const string = Module.currentParseCallback(index, {\n            row,\n            column\n          });\n          if (typeof string === \"string\") {\n            setValue(lengthAddress, string.length, \"i32\");\n            stringToUTF16(string, inputBufferAddress, INPUT_BUFFER_SIZE);\n          } else {\n            setValue(lengthAddress, 0, \"i32\");\n          }\n        }\n        __name(_tree_sitter_parse_callback, \"_tree_sitter_parse_callback\");\n        function _tree_sitter_progress_callback(currentOffset, hasError) {\n          if (Module.currentProgressCallback) {\n            return Module.currentProgressCallback({\n              currentOffset,\n              hasError\n            });\n          }\n          return false;\n        }\n        __name(_tree_sitter_progress_callback, \"_tree_sitter_progress_callback\");\n        function _tree_sitter_query_progress_callback(currentOffset) {\n          if (Module.currentQueryProgressCallback) {\n            return Module.currentQueryProgressCallback({\n              currentOffset\n            });\n          }\n          return false;\n        }\n        __name(_tree_sitter_query_progress_callback, \"_tree_sitter_query_progress_callback\");\n        var runtimeKeepaliveCounter = 0;\n        var keepRuntimeAlive = /* @__PURE__ */ __name(() => noExitRuntime || runtimeKeepaliveCounter > 0, \"keepRuntimeAlive\");\n        var _proc_exit = /* @__PURE__ */ __name((code) => {\n          EXITSTATUS = code;\n          if (!keepRuntimeAlive()) {\n            Module[\"onExit\"]?.(code);\n            ABORT = true;\n          }\n          quit_(code, new ExitStatus(code));\n        }, \"_proc_exit\");\n        _proc_exit.sig = \"vi\";\n        var exitJS = /* @__PURE__ */ __name((status, implicit) => {\n          EXITSTATUS = status;\n          _proc_exit(status);\n        }, \"exitJS\");\n        var handleException = /* @__PURE__ */ __name((e) => {\n          if (e instanceof ExitStatus || e == \"unwind\") {\n            return EXITSTATUS;\n          }\n          quit_(1, e);\n        }, \"handleException\");\n        var lengthBytesUTF8 = /* @__PURE__ */ __name((str) => {\n          var len = 0;\n          for (var i2 = 0; i2 < str.length; ++i2) {\n            var c = str.charCodeAt(i2);\n            if (c <= 127) {\n              len++;\n            } else if (c <= 2047) {\n              len += 2;\n            } else if (c >= 55296 && c <= 57343) {\n              len += 4;\n              ++i2;\n            } else {\n              len += 3;\n            }\n          }\n          return len;\n        }, \"lengthBytesUTF8\");\n        var stringToUTF8Array = /* @__PURE__ */ __name((str, heap, outIdx, maxBytesToWrite) => {\n          if (!(maxBytesToWrite > 0)) return 0;\n          var startIdx = outIdx;\n          var endIdx = outIdx + maxBytesToWrite - 1;\n          for (var i2 = 0; i2 < str.length; ++i2) {\n            var u = str.charCodeAt(i2);\n            if (u >= 55296 && u <= 57343) {\n              var u1 = str.charCodeAt(++i2);\n              u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n            }\n            if (u <= 127) {\n              if (outIdx >= endIdx) break;\n              heap[outIdx++] = u;\n            } else if (u <= 2047) {\n              if (outIdx + 1 >= endIdx) break;\n              heap[outIdx++] = 192 | u >> 6;\n              heap[outIdx++] = 128 | u & 63;\n            } else if (u <= 65535) {\n              if (outIdx + 2 >= endIdx) break;\n              heap[outIdx++] = 224 | u >> 12;\n              heap[outIdx++] = 128 | u >> 6 & 63;\n              heap[outIdx++] = 128 | u & 63;\n            } else {\n              if (outIdx + 3 >= endIdx) break;\n              heap[outIdx++] = 240 | u >> 18;\n              heap[outIdx++] = 128 | u >> 12 & 63;\n              heap[outIdx++] = 128 | u >> 6 & 63;\n              heap[outIdx++] = 128 | u & 63;\n            }\n          }\n          heap[outIdx] = 0;\n          return outIdx - startIdx;\n        }, \"stringToUTF8Array\");\n        var stringToUTF8 = /* @__PURE__ */ __name((str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite), \"stringToUTF8\");\n        var stackAlloc = /* @__PURE__ */ __name((sz) => __emscripten_stack_alloc(sz), \"stackAlloc\");\n        var stringToUTF8OnStack = /* @__PURE__ */ __name((str) => {\n          var size = lengthBytesUTF8(str) + 1;\n          var ret = stackAlloc(size);\n          stringToUTF8(str, ret, size);\n          return ret;\n        }, \"stringToUTF8OnStack\");\n        var AsciiToString = /* @__PURE__ */ __name((ptr) => {\n          var str = \"\";\n          while (1) {\n            var ch = HEAPU8[ptr++];\n            if (!ch) return str;\n            str += String.fromCharCode(ch);\n          }\n        }, \"AsciiToString\");\n        var stringToUTF16 = /* @__PURE__ */ __name((str, outPtr, maxBytesToWrite) => {\n          maxBytesToWrite ??= 2147483647;\n          if (maxBytesToWrite < 2) return 0;\n          maxBytesToWrite -= 2;\n          var startPtr = outPtr;\n          var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n          for (var i2 = 0; i2 < numCharsToWrite; ++i2) {\n            var codeUnit = str.charCodeAt(i2);\n            LE_HEAP_STORE_I16((outPtr >> 1) * 2, codeUnit);\n            outPtr += 2;\n          }\n          LE_HEAP_STORE_I16((outPtr >> 1) * 2, 0);\n          return outPtr - startPtr;\n        }, \"stringToUTF16\");\n        var wasmImports = {\n          /** @export */\n          __heap_base: ___heap_base,\n          /** @export */\n          __indirect_function_table: wasmTable,\n          /** @export */\n          __memory_base: ___memory_base,\n          /** @export */\n          __stack_pointer: ___stack_pointer,\n          /** @export */\n          __table_base: ___table_base,\n          /** @export */\n          _abort_js: __abort_js,\n          /** @export */\n          clock_time_get: _clock_time_get,\n          /** @export */\n          emscripten_resize_heap: _emscripten_resize_heap,\n          /** @export */\n          fd_close: _fd_close,\n          /** @export */\n          fd_seek: _fd_seek,\n          /** @export */\n          fd_write: _fd_write,\n          /** @export */\n          memory: wasmMemory,\n          /** @export */\n          tree_sitter_log_callback: _tree_sitter_log_callback,\n          /** @export */\n          tree_sitter_parse_callback: _tree_sitter_parse_callback,\n          /** @export */\n          tree_sitter_progress_callback: _tree_sitter_progress_callback,\n          /** @export */\n          tree_sitter_query_progress_callback: _tree_sitter_query_progress_callback\n        };\n        var wasmExports = await createWasm();\n        var ___wasm_call_ctors = wasmExports[\"__wasm_call_ctors\"];\n        var _malloc = Module[\"_malloc\"] = wasmExports[\"malloc\"];\n        var _calloc = Module[\"_calloc\"] = wasmExports[\"calloc\"];\n        var _realloc = Module[\"_realloc\"] = wasmExports[\"realloc\"];\n        var _free = Module[\"_free\"] = wasmExports[\"free\"];\n        var _memcmp = Module[\"_memcmp\"] = wasmExports[\"memcmp\"];\n        var _ts_language_symbol_count = Module[\"_ts_language_symbol_count\"] = wasmExports[\"ts_language_symbol_count\"];\n        var _ts_language_state_count = Module[\"_ts_language_state_count\"] = wasmExports[\"ts_language_state_count\"];\n        var _ts_language_version = Module[\"_ts_language_version\"] = wasmExports[\"ts_language_version\"];\n        var _ts_language_abi_version = Module[\"_ts_language_abi_version\"] = wasmExports[\"ts_language_abi_version\"];\n        var _ts_language_metadata = Module[\"_ts_language_metadata\"] = wasmExports[\"ts_language_metadata\"];\n        var _ts_language_name = Module[\"_ts_language_name\"] = wasmExports[\"ts_language_name\"];\n        var _ts_language_field_count = Module[\"_ts_language_field_count\"] = wasmExports[\"ts_language_field_count\"];\n        var _ts_language_next_state = Module[\"_ts_language_next_state\"] = wasmExports[\"ts_language_next_state\"];\n        var _ts_language_symbol_name = Module[\"_ts_language_symbol_name\"] = wasmExports[\"ts_language_symbol_name\"];\n        var _ts_language_symbol_for_name = Module[\"_ts_language_symbol_for_name\"] = wasmExports[\"ts_language_symbol_for_name\"];\n        var _strncmp = Module[\"_strncmp\"] = wasmExports[\"strncmp\"];\n        var _ts_language_symbol_type = Module[\"_ts_language_symbol_type\"] = wasmExports[\"ts_language_symbol_type\"];\n        var _ts_language_field_name_for_id = Module[\"_ts_language_field_name_for_id\"] = wasmExports[\"ts_language_field_name_for_id\"];\n        var _ts_lookahead_iterator_new = Module[\"_ts_lookahead_iterator_new\"] = wasmExports[\"ts_lookahead_iterator_new\"];\n        var _ts_lookahead_iterator_delete = Module[\"_ts_lookahead_iterator_delete\"] = wasmExports[\"ts_lookahead_iterator_delete\"];\n        var _ts_lookahead_iterator_reset_state = Module[\"_ts_lookahead_iterator_reset_state\"] = wasmExports[\"ts_lookahead_iterator_reset_state\"];\n        var _ts_lookahead_iterator_reset = Module[\"_ts_lookahead_iterator_reset\"] = wasmExports[\"ts_lookahead_iterator_reset\"];\n        var _ts_lookahead_iterator_next = Module[\"_ts_lookahead_iterator_next\"] = wasmExports[\"ts_lookahead_iterator_next\"];\n        var _ts_lookahead_iterator_current_symbol = Module[\"_ts_lookahead_iterator_current_symbol\"] = wasmExports[\"ts_lookahead_iterator_current_symbol\"];\n        var _ts_parser_delete = Module[\"_ts_parser_delete\"] = wasmExports[\"ts_parser_delete\"];\n        var _ts_parser_reset = Module[\"_ts_parser_reset\"] = wasmExports[\"ts_parser_reset\"];\n        var _ts_parser_set_language = Module[\"_ts_parser_set_language\"] = wasmExports[\"ts_parser_set_language\"];\n        var _ts_parser_timeout_micros = Module[\"_ts_parser_timeout_micros\"] = wasmExports[\"ts_parser_timeout_micros\"];\n        var _ts_parser_set_timeout_micros = Module[\"_ts_parser_set_timeout_micros\"] = wasmExports[\"ts_parser_set_timeout_micros\"];\n        var _ts_parser_set_included_ranges = Module[\"_ts_parser_set_included_ranges\"] = wasmExports[\"ts_parser_set_included_ranges\"];\n        var _ts_query_new = Module[\"_ts_query_new\"] = wasmExports[\"ts_query_new\"];\n        var _ts_query_delete = Module[\"_ts_query_delete\"] = wasmExports[\"ts_query_delete\"];\n        var _iswspace = Module[\"_iswspace\"] = wasmExports[\"iswspace\"];\n        var _iswalnum = Module[\"_iswalnum\"] = wasmExports[\"iswalnum\"];\n        var _ts_query_pattern_count = Module[\"_ts_query_pattern_count\"] = wasmExports[\"ts_query_pattern_count\"];\n        var _ts_query_capture_count = Module[\"_ts_query_capture_count\"] = wasmExports[\"ts_query_capture_count\"];\n        var _ts_query_string_count = Module[\"_ts_query_string_count\"] = wasmExports[\"ts_query_string_count\"];\n        var _ts_query_capture_name_for_id = Module[\"_ts_query_capture_name_for_id\"] = wasmExports[\"ts_query_capture_name_for_id\"];\n        var _ts_query_capture_quantifier_for_id = Module[\"_ts_query_capture_quantifier_for_id\"] = wasmExports[\"ts_query_capture_quantifier_for_id\"];\n        var _ts_query_string_value_for_id = Module[\"_ts_query_string_value_for_id\"] = wasmExports[\"ts_query_string_value_for_id\"];\n        var _ts_query_predicates_for_pattern = Module[\"_ts_query_predicates_for_pattern\"] = wasmExports[\"ts_query_predicates_for_pattern\"];\n        var _ts_query_start_byte_for_pattern = Module[\"_ts_query_start_byte_for_pattern\"] = wasmExports[\"ts_query_start_byte_for_pattern\"];\n        var _ts_query_end_byte_for_pattern = Module[\"_ts_query_end_byte_for_pattern\"] = wasmExports[\"ts_query_end_byte_for_pattern\"];\n        var _ts_query_is_pattern_rooted = Module[\"_ts_query_is_pattern_rooted\"] = wasmExports[\"ts_query_is_pattern_rooted\"];\n        var _ts_query_is_pattern_non_local = Module[\"_ts_query_is_pattern_non_local\"] = wasmExports[\"ts_query_is_pattern_non_local\"];\n        var _ts_query_is_pattern_guaranteed_at_step = Module[\"_ts_query_is_pattern_guaranteed_at_step\"] = wasmExports[\"ts_query_is_pattern_guaranteed_at_step\"];\n        var _ts_query_disable_capture = Module[\"_ts_query_disable_capture\"] = wasmExports[\"ts_query_disable_capture\"];\n        var _ts_query_disable_pattern = Module[\"_ts_query_disable_pattern\"] = wasmExports[\"ts_query_disable_pattern\"];\n        var _ts_tree_copy = Module[\"_ts_tree_copy\"] = wasmExports[\"ts_tree_copy\"];\n        var _ts_tree_delete = Module[\"_ts_tree_delete\"] = wasmExports[\"ts_tree_delete\"];\n        var _ts_init = Module[\"_ts_init\"] = wasmExports[\"ts_init\"];\n        var _ts_parser_new_wasm = Module[\"_ts_parser_new_wasm\"] = wasmExports[\"ts_parser_new_wasm\"];\n        var _ts_parser_enable_logger_wasm = Module[\"_ts_parser_enable_logger_wasm\"] = wasmExports[\"ts_parser_enable_logger_wasm\"];\n        var _ts_parser_parse_wasm = Module[\"_ts_parser_parse_wasm\"] = wasmExports[\"ts_parser_parse_wasm\"];\n        var _ts_parser_included_ranges_wasm = Module[\"_ts_parser_included_ranges_wasm\"] = wasmExports[\"ts_parser_included_ranges_wasm\"];\n        var _ts_language_type_is_named_wasm = Module[\"_ts_language_type_is_named_wasm\"] = wasmExports[\"ts_language_type_is_named_wasm\"];\n        var _ts_language_type_is_visible_wasm = Module[\"_ts_language_type_is_visible_wasm\"] = wasmExports[\"ts_language_type_is_visible_wasm\"];\n        var _ts_language_supertypes_wasm = Module[\"_ts_language_supertypes_wasm\"] = wasmExports[\"ts_language_supertypes_wasm\"];\n        var _ts_language_subtypes_wasm = Module[\"_ts_language_subtypes_wasm\"] = wasmExports[\"ts_language_subtypes_wasm\"];\n        var _ts_tree_root_node_wasm = Module[\"_ts_tree_root_node_wasm\"] = wasmExports[\"ts_tree_root_node_wasm\"];\n        var _ts_tree_root_node_with_offset_wasm = Module[\"_ts_tree_root_node_with_offset_wasm\"] = wasmExports[\"ts_tree_root_node_with_offset_wasm\"];\n        var _ts_tree_edit_wasm = Module[\"_ts_tree_edit_wasm\"] = wasmExports[\"ts_tree_edit_wasm\"];\n        var _ts_tree_included_ranges_wasm = Module[\"_ts_tree_included_ranges_wasm\"] = wasmExports[\"ts_tree_included_ranges_wasm\"];\n        var _ts_tree_get_changed_ranges_wasm = Module[\"_ts_tree_get_changed_ranges_wasm\"] = wasmExports[\"ts_tree_get_changed_ranges_wasm\"];\n        var _ts_tree_cursor_new_wasm = Module[\"_ts_tree_cursor_new_wasm\"] = wasmExports[\"ts_tree_cursor_new_wasm\"];\n        var _ts_tree_cursor_copy_wasm = Module[\"_ts_tree_cursor_copy_wasm\"] = wasmExports[\"ts_tree_cursor_copy_wasm\"];\n        var _ts_tree_cursor_delete_wasm = Module[\"_ts_tree_cursor_delete_wasm\"] = wasmExports[\"ts_tree_cursor_delete_wasm\"];\n        var _ts_tree_cursor_reset_wasm = Module[\"_ts_tree_cursor_reset_wasm\"] = wasmExports[\"ts_tree_cursor_reset_wasm\"];\n        var _ts_tree_cursor_reset_to_wasm = Module[\"_ts_tree_cursor_reset_to_wasm\"] = wasmExports[\"ts_tree_cursor_reset_to_wasm\"];\n        var _ts_tree_cursor_goto_first_child_wasm = Module[\"_ts_tree_cursor_goto_first_child_wasm\"] = wasmExports[\"ts_tree_cursor_goto_first_child_wasm\"];\n        var _ts_tree_cursor_goto_last_child_wasm = Module[\"_ts_tree_cursor_goto_last_child_wasm\"] = wasmExports[\"ts_tree_cursor_goto_last_child_wasm\"];\n        var _ts_tree_cursor_goto_first_child_for_index_wasm = Module[\"_ts_tree_cursor_goto_first_child_for_index_wasm\"] = wasmExports[\"ts_tree_cursor_goto_first_child_for_index_wasm\"];\n        var _ts_tree_cursor_goto_first_child_for_position_wasm = Module[\"_ts_tree_cursor_goto_first_child_for_position_wasm\"] = wasmExports[\"ts_tree_cursor_goto_first_child_for_position_wasm\"];\n        var _ts_tree_cursor_goto_next_sibling_wasm = Module[\"_ts_tree_cursor_goto_next_sibling_wasm\"] = wasmExports[\"ts_tree_cursor_goto_next_sibling_wasm\"];\n        var _ts_tree_cursor_goto_previous_sibling_wasm = Module[\"_ts_tree_cursor_goto_previous_sibling_wasm\"] = wasmExports[\"ts_tree_cursor_goto_previous_sibling_wasm\"];\n        var _ts_tree_cursor_goto_descendant_wasm = Module[\"_ts_tree_cursor_goto_descendant_wasm\"] = wasmExports[\"ts_tree_cursor_goto_descendant_wasm\"];\n        var _ts_tree_cursor_goto_parent_wasm = Module[\"_ts_tree_cursor_goto_parent_wasm\"] = wasmExports[\"ts_tree_cursor_goto_parent_wasm\"];\n        var _ts_tree_cursor_current_node_type_id_wasm = Module[\"_ts_tree_cursor_current_node_type_id_wasm\"] = wasmExports[\"ts_tree_cursor_current_node_type_id_wasm\"];\n        var _ts_tree_cursor_current_node_state_id_wasm = Module[\"_ts_tree_cursor_current_node_state_id_wasm\"] = wasmExports[\"ts_tree_cursor_current_node_state_id_wasm\"];\n        var _ts_tree_cursor_current_node_is_named_wasm = Module[\"_ts_tree_cursor_current_node_is_named_wasm\"] = wasmExports[\"ts_tree_cursor_current_node_is_named_wasm\"];\n        var _ts_tree_cursor_current_node_is_missing_wasm = Module[\"_ts_tree_cursor_current_node_is_missing_wasm\"] = wasmExports[\"ts_tree_cursor_current_node_is_missing_wasm\"];\n        var _ts_tree_cursor_current_node_id_wasm = Module[\"_ts_tree_cursor_current_node_id_wasm\"] = wasmExports[\"ts_tree_cursor_current_node_id_wasm\"];\n        var _ts_tree_cursor_start_position_wasm = Module[\"_ts_tree_cursor_start_position_wasm\"] = wasmExports[\"ts_tree_cursor_start_position_wasm\"];\n        var _ts_tree_cursor_end_position_wasm = Module[\"_ts_tree_cursor_end_position_wasm\"] = wasmExports[\"ts_tree_cursor_end_position_wasm\"];\n        var _ts_tree_cursor_start_index_wasm = Module[\"_ts_tree_cursor_start_index_wasm\"] = wasmExports[\"ts_tree_cursor_start_index_wasm\"];\n        var _ts_tree_cursor_end_index_wasm = Module[\"_ts_tree_cursor_end_index_wasm\"] = wasmExports[\"ts_tree_cursor_end_index_wasm\"];\n        var _ts_tree_cursor_current_field_id_wasm = Module[\"_ts_tree_cursor_current_field_id_wasm\"] = wasmExports[\"ts_tree_cursor_current_field_id_wasm\"];\n        var _ts_tree_cursor_current_depth_wasm = Module[\"_ts_tree_cursor_current_depth_wasm\"] = wasmExports[\"ts_tree_cursor_current_depth_wasm\"];\n        var _ts_tree_cursor_current_descendant_index_wasm = Module[\"_ts_tree_cursor_current_descendant_index_wasm\"] = wasmExports[\"ts_tree_cursor_current_descendant_index_wasm\"];\n        var _ts_tree_cursor_current_node_wasm = Module[\"_ts_tree_cursor_current_node_wasm\"] = wasmExports[\"ts_tree_cursor_current_node_wasm\"];\n        var _ts_node_symbol_wasm = Module[\"_ts_node_symbol_wasm\"] = wasmExports[\"ts_node_symbol_wasm\"];\n        var _ts_node_field_name_for_child_wasm = Module[\"_ts_node_field_name_for_child_wasm\"] = wasmExports[\"ts_node_field_name_for_child_wasm\"];\n        var _ts_node_field_name_for_named_child_wasm = Module[\"_ts_node_field_name_for_named_child_wasm\"] = wasmExports[\"ts_node_field_name_for_named_child_wasm\"];\n        var _ts_node_children_by_field_id_wasm = Module[\"_ts_node_children_by_field_id_wasm\"] = wasmExports[\"ts_node_children_by_field_id_wasm\"];\n        var _ts_node_first_child_for_byte_wasm = Module[\"_ts_node_first_child_for_byte_wasm\"] = wasmExports[\"ts_node_first_child_for_byte_wasm\"];\n        var _ts_node_first_named_child_for_byte_wasm = Module[\"_ts_node_first_named_child_for_byte_wasm\"] = wasmExports[\"ts_node_first_named_child_for_byte_wasm\"];\n        var _ts_node_grammar_symbol_wasm = Module[\"_ts_node_grammar_symbol_wasm\"] = wasmExports[\"ts_node_grammar_symbol_wasm\"];\n        var _ts_node_child_count_wasm = Module[\"_ts_node_child_count_wasm\"] = wasmExports[\"ts_node_child_count_wasm\"];\n        var _ts_node_named_child_count_wasm = Module[\"_ts_node_named_child_count_wasm\"] = wasmExports[\"ts_node_named_child_count_wasm\"];\n        var _ts_node_child_wasm = Module[\"_ts_node_child_wasm\"] = wasmExports[\"ts_node_child_wasm\"];\n        var _ts_node_named_child_wasm = Module[\"_ts_node_named_child_wasm\"] = wasmExports[\"ts_node_named_child_wasm\"];\n        var _ts_node_child_by_field_id_wasm = Module[\"_ts_node_child_by_field_id_wasm\"] = wasmExports[\"ts_node_child_by_field_id_wasm\"];\n        var _ts_node_next_sibling_wasm = Module[\"_ts_node_next_sibling_wasm\"] = wasmExports[\"ts_node_next_sibling_wasm\"];\n        var _ts_node_prev_sibling_wasm = Module[\"_ts_node_prev_sibling_wasm\"] = wasmExports[\"ts_node_prev_sibling_wasm\"];\n        var _ts_node_next_named_sibling_wasm = Module[\"_ts_node_next_named_sibling_wasm\"] = wasmExports[\"ts_node_next_named_sibling_wasm\"];\n        var _ts_node_prev_named_sibling_wasm = Module[\"_ts_node_prev_named_sibling_wasm\"] = wasmExports[\"ts_node_prev_named_sibling_wasm\"];\n        var _ts_node_descendant_count_wasm = Module[\"_ts_node_descendant_count_wasm\"] = wasmExports[\"ts_node_descendant_count_wasm\"];\n        var _ts_node_parent_wasm = Module[\"_ts_node_parent_wasm\"] = wasmExports[\"ts_node_parent_wasm\"];\n        var _ts_node_child_with_descendant_wasm = Module[\"_ts_node_child_with_descendant_wasm\"] = wasmExports[\"ts_node_child_with_descendant_wasm\"];\n        var _ts_node_descendant_for_index_wasm = Module[\"_ts_node_descendant_for_index_wasm\"] = wasmExports[\"ts_node_descendant_for_index_wasm\"];\n        var _ts_node_named_descendant_for_index_wasm = Module[\"_ts_node_named_descendant_for_index_wasm\"] = wasmExports[\"ts_node_named_descendant_for_index_wasm\"];\n        var _ts_node_descendant_for_position_wasm = Module[\"_ts_node_descendant_for_position_wasm\"] = wasmExports[\"ts_node_descendant_for_position_wasm\"];\n        var _ts_node_named_descendant_for_position_wasm = Module[\"_ts_node_named_descendant_for_position_wasm\"] = wasmExports[\"ts_node_named_descendant_for_position_wasm\"];\n        var _ts_node_start_point_wasm = Module[\"_ts_node_start_point_wasm\"] = wasmExports[\"ts_node_start_point_wasm\"];\n        var _ts_node_end_point_wasm = Module[\"_ts_node_end_point_wasm\"] = wasmExports[\"ts_node_end_point_wasm\"];\n        var _ts_node_start_index_wasm = Module[\"_ts_node_start_index_wasm\"] = wasmExports[\"ts_node_start_index_wasm\"];\n        var _ts_node_end_index_wasm = Module[\"_ts_node_end_index_wasm\"] = wasmExports[\"ts_node_end_index_wasm\"];\n        var _ts_node_to_string_wasm = Module[\"_ts_node_to_string_wasm\"] = wasmExports[\"ts_node_to_string_wasm\"];\n        var _ts_node_children_wasm = Module[\"_ts_node_children_wasm\"] = wasmExports[\"ts_node_children_wasm\"];\n        var _ts_node_named_children_wasm = Module[\"_ts_node_named_children_wasm\"] = wasmExports[\"ts_node_named_children_wasm\"];\n        var _ts_node_descendants_of_type_wasm = Module[\"_ts_node_descendants_of_type_wasm\"] = wasmExports[\"ts_node_descendants_of_type_wasm\"];\n        var _ts_node_is_named_wasm = Module[\"_ts_node_is_named_wasm\"] = wasmExports[\"ts_node_is_named_wasm\"];\n        var _ts_node_has_changes_wasm = Module[\"_ts_node_has_changes_wasm\"] = wasmExports[\"ts_node_has_changes_wasm\"];\n        var _ts_node_has_error_wasm = Module[\"_ts_node_has_error_wasm\"] = wasmExports[\"ts_node_has_error_wasm\"];\n        var _ts_node_is_error_wasm = Module[\"_ts_node_is_error_wasm\"] = wasmExports[\"ts_node_is_error_wasm\"];\n        var _ts_node_is_missing_wasm = Module[\"_ts_node_is_missing_wasm\"] = wasmExports[\"ts_node_is_missing_wasm\"];\n        var _ts_node_is_extra_wasm = Module[\"_ts_node_is_extra_wasm\"] = wasmExports[\"ts_node_is_extra_wasm\"];\n        var _ts_node_parse_state_wasm = Module[\"_ts_node_parse_state_wasm\"] = wasmExports[\"ts_node_parse_state_wasm\"];\n        var _ts_node_next_parse_state_wasm = Module[\"_ts_node_next_parse_state_wasm\"] = wasmExports[\"ts_node_next_parse_state_wasm\"];\n        var _ts_query_matches_wasm = Module[\"_ts_query_matches_wasm\"] = wasmExports[\"ts_query_matches_wasm\"];\n        var _ts_query_captures_wasm = Module[\"_ts_query_captures_wasm\"] = wasmExports[\"ts_query_captures_wasm\"];\n        var _memset = Module[\"_memset\"] = wasmExports[\"memset\"];\n        var _memcpy = Module[\"_memcpy\"] = wasmExports[\"memcpy\"];\n        var _memmove = Module[\"_memmove\"] = wasmExports[\"memmove\"];\n        var _iswalpha = Module[\"_iswalpha\"] = wasmExports[\"iswalpha\"];\n        var _iswblank = Module[\"_iswblank\"] = wasmExports[\"iswblank\"];\n        var _iswdigit = Module[\"_iswdigit\"] = wasmExports[\"iswdigit\"];\n        var _iswlower = Module[\"_iswlower\"] = wasmExports[\"iswlower\"];\n        var _iswupper = Module[\"_iswupper\"] = wasmExports[\"iswupper\"];\n        var _iswxdigit = Module[\"_iswxdigit\"] = wasmExports[\"iswxdigit\"];\n        var _memchr = Module[\"_memchr\"] = wasmExports[\"memchr\"];\n        var _strlen = Module[\"_strlen\"] = wasmExports[\"strlen\"];\n        var _strcmp = Module[\"_strcmp\"] = wasmExports[\"strcmp\"];\n        var _strncat = Module[\"_strncat\"] = wasmExports[\"strncat\"];\n        var _strncpy = Module[\"_strncpy\"] = wasmExports[\"strncpy\"];\n        var _towlower = Module[\"_towlower\"] = wasmExports[\"towlower\"];\n        var _towupper = Module[\"_towupper\"] = wasmExports[\"towupper\"];\n        var _setThrew = wasmExports[\"setThrew\"];\n        var __emscripten_stack_restore = wasmExports[\"_emscripten_stack_restore\"];\n        var __emscripten_stack_alloc = wasmExports[\"_emscripten_stack_alloc\"];\n        var _emscripten_stack_get_current = wasmExports[\"emscripten_stack_get_current\"];\n        var ___wasm_apply_data_relocs = wasmExports[\"__wasm_apply_data_relocs\"];\n        Module[\"setValue\"] = setValue;\n        Module[\"getValue\"] = getValue;\n        Module[\"UTF8ToString\"] = UTF8ToString;\n        Module[\"stringToUTF8\"] = stringToUTF8;\n        Module[\"lengthBytesUTF8\"] = lengthBytesUTF8;\n        Module[\"AsciiToString\"] = AsciiToString;\n        Module[\"stringToUTF16\"] = stringToUTF16;\n        Module[\"loadWebAssemblyModule\"] = loadWebAssemblyModule;\n        function callMain(args2 = []) {\n          var entryFunction = resolveGlobalSymbol(\"main\").sym;\n          if (!entryFunction) return;\n          args2.unshift(thisProgram);\n          var argc = args2.length;\n          var argv = stackAlloc((argc + 1) * 4);\n          var argv_ptr = argv;\n          args2.forEach((arg) => {\n            LE_HEAP_STORE_U32((argv_ptr >> 2) * 4, stringToUTF8OnStack(arg));\n            argv_ptr += 4;\n          });\n          LE_HEAP_STORE_U32((argv_ptr >> 2) * 4, 0);\n          try {\n            var ret = entryFunction(argc, argv);\n            exitJS(\n              ret,\n              /* implicit = */\n              true\n            );\n            return ret;\n          } catch (e) {\n            return handleException(e);\n          }\n        }\n        __name(callMain, \"callMain\");\n        function run(args2 = arguments_) {\n          if (runDependencies > 0) {\n            dependenciesFulfilled = run;\n            return;\n          }\n          preRun();\n          if (runDependencies > 0) {\n            dependenciesFulfilled = run;\n            return;\n          }\n          function doRun() {\n            Module[\"calledRun\"] = true;\n            if (ABORT) return;\n            initRuntime();\n            preMain();\n            readyPromiseResolve(Module);\n            Module[\"onRuntimeInitialized\"]?.();\n            var noInitialRun = Module[\"noInitialRun\"];\n            if (!noInitialRun) callMain(args2);\n            postRun();\n          }\n          __name(doRun, \"doRun\");\n          if (Module[\"setStatus\"]) {\n            Module[\"setStatus\"](\"Running...\");\n            setTimeout(() => {\n              setTimeout(() => Module[\"setStatus\"](\"\"), 1);\n              doRun();\n            }, 1);\n          } else {\n            doRun();\n          }\n        }\n        __name(run, \"run\");\n        if (Module[\"preInit\"]) {\n          if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n          while (Module[\"preInit\"].length > 0) {\n            Module[\"preInit\"].pop()();\n          }\n        }\n        run();\n        moduleRtn = readyPromise;\n        return moduleRtn;\n      };\n    })();\n    if (typeof exports === \"object\" && typeof module === \"object\") {\n      module.exports = Module;\n      module.exports.default = Module;\n    } else if (typeof define === \"function\" && define[\"amd\"])\n      define([], () => Module);\n  }\n});\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  CaptureQuantifier: () => CaptureQuantifier,\n  LANGUAGE_VERSION: () => LANGUAGE_VERSION,\n  Language: () => Language,\n  LookaheadIterator: () => LookaheadIterator,\n  MIN_COMPATIBLE_VERSION: () => MIN_COMPATIBLE_VERSION,\n  Node: () => Node,\n  Parser: () => Parser,\n  Query: () => Query,\n  Tree: () => Tree,\n  TreeCursor: () => TreeCursor\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/constants.ts\nvar SIZE_OF_SHORT = 2;\nvar SIZE_OF_INT = 4;\nvar SIZE_OF_CURSOR = 4 * SIZE_OF_INT;\nvar SIZE_OF_NODE = 5 * SIZE_OF_INT;\nvar SIZE_OF_POINT = 2 * SIZE_OF_INT;\nvar SIZE_OF_RANGE = 2 * SIZE_OF_INT + 2 * SIZE_OF_POINT;\nvar ZERO_POINT = { row: 0, column: 0 };\nvar INTERNAL = Symbol(\"INTERNAL\");\nfunction assertInternal(x) {\n  if (x !== INTERNAL) throw new Error(\"Illegal constructor\");\n}\n__name(assertInternal, \"assertInternal\");\nfunction isPoint(point) {\n  return !!point && typeof point.row === \"number\" && typeof point.column === \"number\";\n}\n__name(isPoint, \"isPoint\");\nfunction setModule(module2) {\n  C = module2;\n}\n__name(setModule, \"setModule\");\nvar C;\n\n// src/lookahead_iterator.ts\nvar LookaheadIterator = class {\n  static {\n    __name(this, \"LookaheadIterator\");\n  }\n  /** @internal */\n  [0] = 0;\n  // Internal handle for WASM\n  /** @internal */\n  language;\n  /** @internal */\n  constructor(internal, address, language) {\n    assertInternal(internal);\n    this[0] = address;\n    this.language = language;\n  }\n  /** Get the current symbol of the lookahead iterator. */\n  get currentTypeId() {\n    return C._ts_lookahead_iterator_current_symbol(this[0]);\n  }\n  /** Get the current symbol name of the lookahead iterator. */\n  get currentType() {\n    return this.language.types[this.currentTypeId] || \"ERROR\";\n  }\n  /** Delete the lookahead iterator, freeing its resources. */\n  delete() {\n    C._ts_lookahead_iterator_delete(this[0]);\n    this[0] = 0;\n  }\n  /**\n   * Reset the lookahead iterator.\n   *\n   * This returns `true` if the language was set successfully and `false`\n   * otherwise.\n   */\n  reset(language, stateId) {\n    if (C._ts_lookahead_iterator_reset(this[0], language[0], stateId)) {\n      this.language = language;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Reset the lookahead iterator to another state.\n   *\n   * This returns `true` if the iterator was reset to the given state and\n   * `false` otherwise.\n   */\n  resetState(stateId) {\n    return Boolean(C._ts_lookahead_iterator_reset_state(this[0], stateId));\n  }\n  /**\n   * Returns an iterator that iterates over the symbols of the lookahead iterator.\n   *\n   * The iterator will yield the current symbol name as a string for each step\n   * until there are no more symbols to iterate over.\n   */\n  [Symbol.iterator]() {\n    return {\n      next: /* @__PURE__ */ __name(() => {\n        if (C._ts_lookahead_iterator_next(this[0])) {\n          return { done: false, value: this.currentType };\n        }\n        return { done: true, value: \"\" };\n      }, \"next\")\n    };\n  }\n};\n\n// src/tree.ts\nfunction getText(tree, startIndex, endIndex, startPosition) {\n  const length = endIndex - startIndex;\n  let result = tree.textCallback(startIndex, startPosition);\n  if (result) {\n    startIndex += result.length;\n    while (startIndex < endIndex) {\n      const string = tree.textCallback(startIndex, startPosition);\n      if (string && string.length > 0) {\n        startIndex += string.length;\n        result += string;\n      } else {\n        break;\n      }\n    }\n    if (startIndex > endIndex) {\n      result = result.slice(0, length);\n    }\n  }\n  return result ?? \"\";\n}\n__name(getText, \"getText\");\nvar Tree = class _Tree {\n  static {\n    __name(this, \"Tree\");\n  }\n  /** @internal */\n  [0] = 0;\n  // Internal handle for WASM\n  /** @internal */\n  textCallback;\n  /** The language that was used to parse the syntax tree. */\n  language;\n  /** @internal */\n  constructor(internal, address, language, textCallback) {\n    assertInternal(internal);\n    this[0] = address;\n    this.language = language;\n    this.textCallback = textCallback;\n  }\n  /** Create a shallow copy of the syntax tree. This is very fast. */\n  copy() {\n    const address = C._ts_tree_copy(this[0]);\n    return new _Tree(INTERNAL, address, this.language, this.textCallback);\n  }\n  /** Delete the syntax tree, freeing its resources. */\n  delete() {\n    C._ts_tree_delete(this[0]);\n    this[0] = 0;\n  }\n  /** Get the root node of the syntax tree. */\n  get rootNode() {\n    C._ts_tree_root_node_wasm(this[0]);\n    return unmarshalNode(this);\n  }\n  /**\n   * Get the root node of the syntax tree, but with its position shifted\n   * forward by the given offset.\n   */\n  rootNodeWithOffset(offsetBytes, offsetExtent) {\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, offsetBytes, \"i32\");\n    marshalPoint(address + SIZE_OF_INT, offsetExtent);\n    C._ts_tree_root_node_with_offset_wasm(this[0]);\n    return unmarshalNode(this);\n  }\n  /**\n   * Edit the syntax tree to keep it in sync with source code that has been\n   * edited.\n   *\n   * You must describe the edit both in terms of byte offsets and in terms of\n   * row/column coordinates.\n   */\n  edit(edit) {\n    marshalEdit(edit);\n    C._ts_tree_edit_wasm(this[0]);\n  }\n  /** Create a new {@link TreeCursor} starting from the root of the tree. */\n  walk() {\n    return this.rootNode.walk();\n  }\n  /**\n   * Compare this old edited syntax tree to a new syntax tree representing\n   * the same document, returning a sequence of ranges whose syntactic\n   * structure has changed.\n   *\n   * For this to work correctly, this syntax tree must have been edited such\n   * that its ranges match up to the new tree. Generally, you'll want to\n   * call this method right after calling one of the [`Parser::parse`]\n   * functions. Call it on the old tree that was passed to parse, and\n   * pass the new tree that was returned from `parse`.\n   */\n  getChangedRanges(other) {\n    if (!(other instanceof _Tree)) {\n      throw new TypeError(\"Argument must be a Tree\");\n    }\n    C._ts_tree_get_changed_ranges_wasm(this[0], other[0]);\n    const count = C.getValue(TRANSFER_BUFFER, \"i32\");\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n    const result = new Array(count);\n    if (count > 0) {\n      let address = buffer;\n      for (let i2 = 0; i2 < count; i2++) {\n        result[i2] = unmarshalRange(address);\n        address += SIZE_OF_RANGE;\n      }\n      C._free(buffer);\n    }\n    return result;\n  }\n  /** Get the included ranges that were used to parse the syntax tree. */\n  getIncludedRanges() {\n    C._ts_tree_included_ranges_wasm(this[0]);\n    const count = C.getValue(TRANSFER_BUFFER, \"i32\");\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n    const result = new Array(count);\n    if (count > 0) {\n      let address = buffer;\n      for (let i2 = 0; i2 < count; i2++) {\n        result[i2] = unmarshalRange(address);\n        address += SIZE_OF_RANGE;\n      }\n      C._free(buffer);\n    }\n    return result;\n  }\n};\n\n// src/tree_cursor.ts\nvar TreeCursor = class _TreeCursor {\n  static {\n    __name(this, \"TreeCursor\");\n  }\n  /** @internal */\n  // @ts-expect-error: never read\n  [0] = 0;\n  // Internal handle for Wasm\n  /** @internal */\n  // @ts-expect-error: never read\n  [1] = 0;\n  // Internal handle for Wasm\n  /** @internal */\n  // @ts-expect-error: never read\n  [2] = 0;\n  // Internal handle for Wasm\n  /** @internal */\n  // @ts-expect-error: never read\n  [3] = 0;\n  // Internal handle for Wasm\n  /** @internal */\n  tree;\n  /** @internal */\n  constructor(internal, tree) {\n    assertInternal(internal);\n    this.tree = tree;\n    unmarshalTreeCursor(this);\n  }\n  /** Creates a deep copy of the tree cursor. This allocates new memory. */\n  copy() {\n    const copy = new _TreeCursor(INTERNAL, this.tree);\n    C._ts_tree_cursor_copy_wasm(this.tree[0]);\n    unmarshalTreeCursor(copy);\n    return copy;\n  }\n  /** Delete the tree cursor, freeing its resources. */\n  delete() {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_delete_wasm(this.tree[0]);\n    this[0] = this[1] = this[2] = 0;\n  }\n  /** Get the tree cursor's current {@link Node}. */\n  get currentNode() {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_current_node_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /**\n   * Get the numerical field id of this tree cursor's current node.\n   *\n   * See also {@link TreeCursor#currentFieldName}.\n   */\n  get currentFieldId() {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_field_id_wasm(this.tree[0]);\n  }\n  /** Get the field name of this tree cursor's current node. */\n  get currentFieldName() {\n    return this.tree.language.fields[this.currentFieldId];\n  }\n  /**\n   * Get the depth of the cursor's current node relative to the original\n   * node that the cursor was constructed with.\n   */\n  get currentDepth() {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_depth_wasm(this.tree[0]);\n  }\n  /**\n   * Get the index of the cursor's current node out of all of the\n   * descendants of the original node that the cursor was constructed with.\n   */\n  get currentDescendantIndex() {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_descendant_index_wasm(this.tree[0]);\n  }\n  /** Get the type of the cursor's current node. */\n  get nodeType() {\n    return this.tree.language.types[this.nodeTypeId] || \"ERROR\";\n  }\n  /** Get the type id of the cursor's current node. */\n  get nodeTypeId() {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);\n  }\n  /** Get the state id of the cursor's current node. */\n  get nodeStateId() {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_state_id_wasm(this.tree[0]);\n  }\n  /** Get the id of the cursor's current node. */\n  get nodeId() {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_id_wasm(this.tree[0]);\n  }\n  /**\n   * Check if the cursor's current node is *named*.\n   *\n   * Named nodes correspond to named rules in the grammar, whereas\n   * *anonymous* nodes correspond to string literals in the grammar.\n   */\n  get nodeIsNamed() {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1;\n  }\n  /**\n   * Check if the cursor's current node is *missing*.\n   *\n   * Missing nodes are inserted by the parser in order to recover from\n   * certain kinds of syntax errors.\n   */\n  get nodeIsMissing() {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1;\n  }\n  /** Get the string content of the cursor's current node. */\n  get nodeText() {\n    marshalTreeCursor(this);\n    const startIndex = C._ts_tree_cursor_start_index_wasm(this.tree[0]);\n    const endIndex = C._ts_tree_cursor_end_index_wasm(this.tree[0]);\n    C._ts_tree_cursor_start_position_wasm(this.tree[0]);\n    const startPosition = unmarshalPoint(TRANSFER_BUFFER);\n    return getText(this.tree, startIndex, endIndex, startPosition);\n  }\n  /** Get the start position of the cursor's current node. */\n  get startPosition() {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_start_position_wasm(this.tree[0]);\n    return unmarshalPoint(TRANSFER_BUFFER);\n  }\n  /** Get the end position of the cursor's current node. */\n  get endPosition() {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_end_position_wasm(this.tree[0]);\n    return unmarshalPoint(TRANSFER_BUFFER);\n  }\n  /** Get the start index of the cursor's current node. */\n  get startIndex() {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_start_index_wasm(this.tree[0]);\n  }\n  /** Get the end index of the cursor's current node. */\n  get endIndex() {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_end_index_wasm(this.tree[0]);\n  }\n  /**\n   * Move this cursor to the first child of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there were no children.\n   */\n  gotoFirstChild() {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n  /**\n   * Move this cursor to the last child of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there were no children.\n   *\n   * Note that this function may be slower than\n   * {@link TreeCursor#gotoFirstChild} because it needs to\n   * iterate through all the children to compute the child's position.\n   */\n  gotoLastChild() {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_last_child_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n  /**\n   * Move this cursor to the parent of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there was no parent node (the cursor was already on the\n   * root node).\n   *\n   * Note that the node the cursor was constructed with is considered the root\n   * of the cursor, and the cursor cannot walk outside this node.\n   */\n  gotoParent() {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_parent_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n  /**\n   * Move this cursor to the next sibling of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there was no next sibling node.\n   *\n   * Note that the node the cursor was constructed with is considered the root\n   * of the cursor, and the cursor cannot walk outside this node.\n   */\n  gotoNextSibling() {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n  /**\n   * Move this cursor to the previous sibling of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there was no previous sibling node.\n   *\n   * Note that this function may be slower than\n   * {@link TreeCursor#gotoNextSibling} due to how node\n   * positions are stored. In the worst case, this will need to iterate\n   * through all the children up to the previous sibling node to recalculate\n   * its position. Also note that the node the cursor was constructed with is\n   * considered the root of the cursor, and the cursor cannot walk outside this node.\n   */\n  gotoPreviousSibling() {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_previous_sibling_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n  /**\n   * Move the cursor to the node that is the nth descendant of\n   * the original node that the cursor was constructed with, where\n   * zero represents the original node itself.\n   */\n  gotoDescendant(goalDescendantIndex) {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_goto_descendant_wasm(this.tree[0], goalDescendantIndex);\n    unmarshalTreeCursor(this);\n  }\n  /**\n   * Move this cursor to the first child of its current node that contains or\n   * starts after the given byte offset.\n   *\n   * This returns `true` if the cursor successfully moved to a child node, and returns\n   * `false` if no such child was found.\n   */\n  gotoFirstChildForIndex(goalIndex) {\n    marshalTreeCursor(this);\n    C.setValue(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalIndex, \"i32\");\n    const result = C._ts_tree_cursor_goto_first_child_for_index_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n  /**\n   * Move this cursor to the first child of its current node that contains or\n   * starts after the given byte offset.\n   *\n   * This returns the index of the child node if one was found, and returns\n   * `null` if no such child was found.\n   */\n  gotoFirstChildForPosition(goalPosition) {\n    marshalTreeCursor(this);\n    marshalPoint(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalPosition);\n    const result = C._ts_tree_cursor_goto_first_child_for_position_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n  /**\n   * Re-initialize this tree cursor to start at the original node that the\n   * cursor was constructed with.\n   */\n  reset(node) {\n    marshalNode(node);\n    marshalTreeCursor(this, TRANSFER_BUFFER + SIZE_OF_NODE);\n    C._ts_tree_cursor_reset_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n  }\n  /**\n   * Re-initialize a tree cursor to the same position as another cursor.\n   *\n   * Unlike {@link TreeCursor#reset}, this will not lose parent\n   * information and allows reusing already created cursors.\n   */\n  resetTo(cursor) {\n    marshalTreeCursor(this, TRANSFER_BUFFER);\n    marshalTreeCursor(cursor, TRANSFER_BUFFER + SIZE_OF_CURSOR);\n    C._ts_tree_cursor_reset_to_wasm(this.tree[0], cursor.tree[0]);\n    unmarshalTreeCursor(this);\n  }\n};\n\n// src/node.ts\nvar Node = class {\n  static {\n    __name(this, \"Node\");\n  }\n  /** @internal */\n  // @ts-expect-error: never read\n  [0] = 0;\n  // Internal handle for Wasm\n  /** @internal */\n  _children;\n  /** @internal */\n  _namedChildren;\n  /** @internal */\n  constructor(internal, {\n    id,\n    tree,\n    startIndex,\n    startPosition,\n    other\n  }) {\n    assertInternal(internal);\n    this[0] = other;\n    this.id = id;\n    this.tree = tree;\n    this.startIndex = startIndex;\n    this.startPosition = startPosition;\n  }\n  /**\n   * The numeric id for this node that is unique.\n   *\n   * Within a given syntax tree, no two nodes have the same id. However:\n   *\n   * * If a new tree is created based on an older tree, and a node from the old tree is reused in\n   *   the process, then that node will have the same id in both trees.\n   *\n   * * A node not marked as having changes does not guarantee it was reused.\n   *\n   * * If a node is marked as having changed in the old tree, it will not be reused.\n   */\n  id;\n  /** The byte index where this node starts. */\n  startIndex;\n  /** The position where this node starts. */\n  startPosition;\n  /** The tree that this node belongs to. */\n  tree;\n  /** Get this node's type as a numerical id. */\n  get typeId() {\n    marshalNode(this);\n    return C._ts_node_symbol_wasm(this.tree[0]);\n  }\n  /**\n   * Get the node's type as a numerical id as it appears in the grammar,\n   * ignoring aliases.\n   */\n  get grammarId() {\n    marshalNode(this);\n    return C._ts_node_grammar_symbol_wasm(this.tree[0]);\n  }\n  /** Get this node's type as a string. */\n  get type() {\n    return this.tree.language.types[this.typeId] || \"ERROR\";\n  }\n  /**\n   * Get this node's symbol name as it appears in the grammar, ignoring\n   * aliases as a string.\n   */\n  get grammarType() {\n    return this.tree.language.types[this.grammarId] || \"ERROR\";\n  }\n  /**\n   * Check if this node is *named*.\n   *\n   * Named nodes correspond to named rules in the grammar, whereas\n   * *anonymous* nodes correspond to string literals in the grammar.\n   */\n  get isNamed() {\n    marshalNode(this);\n    return C._ts_node_is_named_wasm(this.tree[0]) === 1;\n  }\n  /**\n   * Check if this node is *extra*.\n   *\n   * Extra nodes represent things like comments, which are not required\n   * by the grammar, but can appear anywhere.\n   */\n  get isExtra() {\n    marshalNode(this);\n    return C._ts_node_is_extra_wasm(this.tree[0]) === 1;\n  }\n  /**\n   * Check if this node represents a syntax error.\n   *\n   * Syntax errors represent parts of the code that could not be incorporated\n   * into a valid syntax tree.\n   */\n  get isError() {\n    marshalNode(this);\n    return C._ts_node_is_error_wasm(this.tree[0]) === 1;\n  }\n  /**\n   * Check if this node is *missing*.\n   *\n   * Missing nodes are inserted by the parser in order to recover from\n   * certain kinds of syntax errors.\n   */\n  get isMissing() {\n    marshalNode(this);\n    return C._ts_node_is_missing_wasm(this.tree[0]) === 1;\n  }\n  /** Check if this node has been edited. */\n  get hasChanges() {\n    marshalNode(this);\n    return C._ts_node_has_changes_wasm(this.tree[0]) === 1;\n  }\n  /**\n   * Check if this node represents a syntax error or contains any syntax\n   * errors anywhere within it.\n   */\n  get hasError() {\n    marshalNode(this);\n    return C._ts_node_has_error_wasm(this.tree[0]) === 1;\n  }\n  /** Get the byte index where this node ends. */\n  get endIndex() {\n    marshalNode(this);\n    return C._ts_node_end_index_wasm(this.tree[0]);\n  }\n  /** Get the position where this node ends. */\n  get endPosition() {\n    marshalNode(this);\n    C._ts_node_end_point_wasm(this.tree[0]);\n    return unmarshalPoint(TRANSFER_BUFFER);\n  }\n  /** Get the string content of this node. */\n  get text() {\n    return getText(this.tree, this.startIndex, this.endIndex, this.startPosition);\n  }\n  /** Get this node's parse state. */\n  get parseState() {\n    marshalNode(this);\n    return C._ts_node_parse_state_wasm(this.tree[0]);\n  }\n  /** Get the parse state after this node. */\n  get nextParseState() {\n    marshalNode(this);\n    return C._ts_node_next_parse_state_wasm(this.tree[0]);\n  }\n  /** Check if this node is equal to another node. */\n  equals(other) {\n    return this.tree === other.tree && this.id === other.id;\n  }\n  /**\n   * Get the node's child at the given index, where zero represents the first child.\n   *\n   * This method is fairly fast, but its cost is technically log(n), so if\n   * you might be iterating over a long list of children, you should use\n   * {@link Node#children} instead.\n   */\n  child(index) {\n    marshalNode(this);\n    C._ts_node_child_wasm(this.tree[0], index);\n    return unmarshalNode(this.tree);\n  }\n  /**\n   * Get this node's *named* child at the given index.\n   *\n   * See also {@link Node#isNamed}.\n   * This method is fairly fast, but its cost is technically log(n), so if\n   * you might be iterating over a long list of children, you should use\n   * {@link Node#namedChildren} instead.\n   */\n  namedChild(index) {\n    marshalNode(this);\n    C._ts_node_named_child_wasm(this.tree[0], index);\n    return unmarshalNode(this.tree);\n  }\n  /**\n   * Get this node's child with the given numerical field id.\n   *\n   * See also {@link Node#childForFieldName}. You can\n   * convert a field name to an id using {@link Language#fieldIdForName}.\n   */\n  childForFieldId(fieldId) {\n    marshalNode(this);\n    C._ts_node_child_by_field_id_wasm(this.tree[0], fieldId);\n    return unmarshalNode(this.tree);\n  }\n  /**\n   * Get the first child with the given field name.\n   *\n   * If multiple children may have the same field name, access them using\n   * {@link Node#childrenForFieldName}.\n   */\n  childForFieldName(fieldName) {\n    const fieldId = this.tree.language.fields.indexOf(fieldName);\n    if (fieldId !== -1) return this.childForFieldId(fieldId);\n    return null;\n  }\n  /** Get the field name of this node's child at the given index. */\n  fieldNameForChild(index) {\n    marshalNode(this);\n    const address = C._ts_node_field_name_for_child_wasm(this.tree[0], index);\n    if (!address) return null;\n    return C.AsciiToString(address);\n  }\n  /** Get the field name of this node's named child at the given index. */\n  fieldNameForNamedChild(index) {\n    marshalNode(this);\n    const address = C._ts_node_field_name_for_named_child_wasm(this.tree[0], index);\n    if (!address) return null;\n    return C.AsciiToString(address);\n  }\n  /**\n   * Get an array of this node's children with a given field name.\n   *\n   * See also {@link Node#children}.\n   */\n  childrenForFieldName(fieldName) {\n    const fieldId = this.tree.language.fields.indexOf(fieldName);\n    if (fieldId !== -1 && fieldId !== 0) return this.childrenForFieldId(fieldId);\n    return [];\n  }\n  /**\n    * Get an array of this node's children with a given field id.\n    *\n    * See also {@link Node#childrenForFieldName}.\n    */\n  childrenForFieldId(fieldId) {\n    marshalNode(this);\n    C._ts_node_children_by_field_id_wasm(this.tree[0], fieldId);\n    const count = C.getValue(TRANSFER_BUFFER, \"i32\");\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n    const result = new Array(count);\n    if (count > 0) {\n      let address = buffer;\n      for (let i2 = 0; i2 < count; i2++) {\n        result[i2] = unmarshalNode(this.tree, address);\n        address += SIZE_OF_NODE;\n      }\n      C._free(buffer);\n    }\n    return result;\n  }\n  /** Get the node's first child that contains or starts after the given byte offset. */\n  firstChildForIndex(index) {\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, index, \"i32\");\n    C._ts_node_first_child_for_byte_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /** Get the node's first named child that contains or starts after the given byte offset. */\n  firstNamedChildForIndex(index) {\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, index, \"i32\");\n    C._ts_node_first_named_child_for_byte_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /** Get this node's number of children. */\n  get childCount() {\n    marshalNode(this);\n    return C._ts_node_child_count_wasm(this.tree[0]);\n  }\n  /**\n   * Get this node's number of *named* children.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get namedChildCount() {\n    marshalNode(this);\n    return C._ts_node_named_child_count_wasm(this.tree[0]);\n  }\n  /** Get this node's first child. */\n  get firstChild() {\n    return this.child(0);\n  }\n  /**\n   * Get this node's first named child.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get firstNamedChild() {\n    return this.namedChild(0);\n  }\n  /** Get this node's last child. */\n  get lastChild() {\n    return this.child(this.childCount - 1);\n  }\n  /**\n   * Get this node's last named child.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get lastNamedChild() {\n    return this.namedChild(this.namedChildCount - 1);\n  }\n  /**\n   * Iterate over this node's children.\n   *\n   * If you're walking the tree recursively, you may want to use the\n   * {@link TreeCursor} APIs directly instead.\n   */\n  get children() {\n    if (!this._children) {\n      marshalNode(this);\n      C._ts_node_children_wasm(this.tree[0]);\n      const count = C.getValue(TRANSFER_BUFFER, \"i32\");\n      const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n      this._children = new Array(count);\n      if (count > 0) {\n        let address = buffer;\n        for (let i2 = 0; i2 < count; i2++) {\n          this._children[i2] = unmarshalNode(this.tree, address);\n          address += SIZE_OF_NODE;\n        }\n        C._free(buffer);\n      }\n    }\n    return this._children;\n  }\n  /**\n   * Iterate over this node's named children.\n   *\n   * See also {@link Node#children}.\n   */\n  get namedChildren() {\n    if (!this._namedChildren) {\n      marshalNode(this);\n      C._ts_node_named_children_wasm(this.tree[0]);\n      const count = C.getValue(TRANSFER_BUFFER, \"i32\");\n      const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n      this._namedChildren = new Array(count);\n      if (count > 0) {\n        let address = buffer;\n        for (let i2 = 0; i2 < count; i2++) {\n          this._namedChildren[i2] = unmarshalNode(this.tree, address);\n          address += SIZE_OF_NODE;\n        }\n        C._free(buffer);\n      }\n    }\n    return this._namedChildren;\n  }\n  /**\n   * Get the descendants of this node that are the given type, or in the given types array.\n   *\n   * The types array should contain node type strings, which can be retrieved from {@link Language#types}.\n   *\n   * Additionally, a `startPosition` and `endPosition` can be passed in to restrict the search to a byte range.\n   */\n  descendantsOfType(types, startPosition = ZERO_POINT, endPosition = ZERO_POINT) {\n    if (!Array.isArray(types)) types = [types];\n    const symbols = [];\n    const typesBySymbol = this.tree.language.types;\n    for (const node_type of types) {\n      if (node_type == \"ERROR\") {\n        symbols.push(65535);\n      }\n    }\n    for (let i2 = 0, n = typesBySymbol.length; i2 < n; i2++) {\n      if (types.includes(typesBySymbol[i2])) {\n        symbols.push(i2);\n      }\n    }\n    const symbolsAddress = C._malloc(SIZE_OF_INT * symbols.length);\n    for (let i2 = 0, n = symbols.length; i2 < n; i2++) {\n      C.setValue(symbolsAddress + i2 * SIZE_OF_INT, symbols[i2], \"i32\");\n    }\n    marshalNode(this);\n    C._ts_node_descendants_of_type_wasm(\n      this.tree[0],\n      symbolsAddress,\n      symbols.length,\n      startPosition.row,\n      startPosition.column,\n      endPosition.row,\n      endPosition.column\n    );\n    const descendantCount = C.getValue(TRANSFER_BUFFER, \"i32\");\n    const descendantAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n    const result = new Array(descendantCount);\n    if (descendantCount > 0) {\n      let address = descendantAddress;\n      for (let i2 = 0; i2 < descendantCount; i2++) {\n        result[i2] = unmarshalNode(this.tree, address);\n        address += SIZE_OF_NODE;\n      }\n    }\n    C._free(descendantAddress);\n    C._free(symbolsAddress);\n    return result;\n  }\n  /** Get this node's next sibling. */\n  get nextSibling() {\n    marshalNode(this);\n    C._ts_node_next_sibling_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /** Get this node's previous sibling. */\n  get previousSibling() {\n    marshalNode(this);\n    C._ts_node_prev_sibling_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /**\n   * Get this node's next *named* sibling.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get nextNamedSibling() {\n    marshalNode(this);\n    C._ts_node_next_named_sibling_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /**\n   * Get this node's previous *named* sibling.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get previousNamedSibling() {\n    marshalNode(this);\n    C._ts_node_prev_named_sibling_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /** Get the node's number of descendants, including one for the node itself. */\n  get descendantCount() {\n    marshalNode(this);\n    return C._ts_node_descendant_count_wasm(this.tree[0]);\n  }\n  /**\n   * Get this node's immediate parent.\n   * Prefer {@link Node#childWithDescendant} for iterating over this node's ancestors.\n   */\n  get parent() {\n    marshalNode(this);\n    C._ts_node_parent_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /**\n   * Get the node that contains `descendant`.\n   *\n   * Note that this can return `descendant` itself.\n   */\n  childWithDescendant(descendant) {\n    marshalNode(this);\n    marshalNode(descendant, 1);\n    C._ts_node_child_with_descendant_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /** Get the smallest node within this node that spans the given byte range. */\n  descendantForIndex(start2, end = start2) {\n    if (typeof start2 !== \"number\" || typeof end !== \"number\") {\n      throw new Error(\"Arguments must be numbers\");\n    }\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, start2, \"i32\");\n    C.setValue(address + SIZE_OF_INT, end, \"i32\");\n    C._ts_node_descendant_for_index_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /** Get the smallest named node within this node that spans the given byte range. */\n  namedDescendantForIndex(start2, end = start2) {\n    if (typeof start2 !== \"number\" || typeof end !== \"number\") {\n      throw new Error(\"Arguments must be numbers\");\n    }\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, start2, \"i32\");\n    C.setValue(address + SIZE_OF_INT, end, \"i32\");\n    C._ts_node_named_descendant_for_index_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /** Get the smallest node within this node that spans the given point range. */\n  descendantForPosition(start2, end = start2) {\n    if (!isPoint(start2) || !isPoint(end)) {\n      throw new Error(\"Arguments must be {row, column} objects\");\n    }\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    marshalPoint(address, start2);\n    marshalPoint(address + SIZE_OF_POINT, end);\n    C._ts_node_descendant_for_position_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /** Get the smallest named node within this node that spans the given point range. */\n  namedDescendantForPosition(start2, end = start2) {\n    if (!isPoint(start2) || !isPoint(end)) {\n      throw new Error(\"Arguments must be {row, column} objects\");\n    }\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    marshalPoint(address, start2);\n    marshalPoint(address + SIZE_OF_POINT, end);\n    C._ts_node_named_descendant_for_position_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n  /**\n   * Create a new {@link TreeCursor} starting from this node.\n   *\n   * Note that the given node is considered the root of the cursor,\n   * and the cursor cannot walk outside this node.\n   */\n  walk() {\n    marshalNode(this);\n    C._ts_tree_cursor_new_wasm(this.tree[0]);\n    return new TreeCursor(INTERNAL, this.tree);\n  }\n  /**\n   * Edit this node to keep it in-sync with source code that has been edited.\n   *\n   * This function is only rarely needed. When you edit a syntax tree with\n   * the {@link Tree#edit} method, all of the nodes that you retrieve from\n   * the tree afterward will already reflect the edit. You only need to\n   * use {@link Node#edit} when you have a specific {@link Node} instance that\n   * you want to keep and continue to use after an edit.\n   */\n  edit(edit) {\n    if (this.startIndex >= edit.oldEndIndex) {\n      this.startIndex = edit.newEndIndex + (this.startIndex - edit.oldEndIndex);\n      let subbedPointRow;\n      let subbedPointColumn;\n      if (this.startPosition.row > edit.oldEndPosition.row) {\n        subbedPointRow = this.startPosition.row - edit.oldEndPosition.row;\n        subbedPointColumn = this.startPosition.column;\n      } else {\n        subbedPointRow = 0;\n        subbedPointColumn = this.startPosition.column;\n        if (this.startPosition.column >= edit.oldEndPosition.column) {\n          subbedPointColumn = this.startPosition.column - edit.oldEndPosition.column;\n        }\n      }\n      if (subbedPointRow > 0) {\n        this.startPosition.row += subbedPointRow;\n        this.startPosition.column = subbedPointColumn;\n      } else {\n        this.startPosition.column += subbedPointColumn;\n      }\n    } else if (this.startIndex > edit.startIndex) {\n      this.startIndex = edit.newEndIndex;\n      this.startPosition.row = edit.newEndPosition.row;\n      this.startPosition.column = edit.newEndPosition.column;\n    }\n  }\n  /** Get the S-expression representation of this node. */\n  toString() {\n    marshalNode(this);\n    const address = C._ts_node_to_string_wasm(this.tree[0]);\n    const result = C.AsciiToString(address);\n    C._free(address);\n    return result;\n  }\n};\n\n// src/marshal.ts\nfunction unmarshalCaptures(query, tree, address, patternIndex, result) {\n  for (let i2 = 0, n = result.length; i2 < n; i2++) {\n    const captureIndex = C.getValue(address, \"i32\");\n    address += SIZE_OF_INT;\n    const node = unmarshalNode(tree, address);\n    address += SIZE_OF_NODE;\n    result[i2] = { patternIndex, name: query.captureNames[captureIndex], node };\n  }\n  return address;\n}\n__name(unmarshalCaptures, \"unmarshalCaptures\");\nfunction marshalNode(node, index = 0) {\n  let address = TRANSFER_BUFFER + index * SIZE_OF_NODE;\n  C.setValue(address, node.id, \"i32\");\n  address += SIZE_OF_INT;\n  C.setValue(address, node.startIndex, \"i32\");\n  address += SIZE_OF_INT;\n  C.setValue(address, node.startPosition.row, \"i32\");\n  address += SIZE_OF_INT;\n  C.setValue(address, node.startPosition.column, \"i32\");\n  address += SIZE_OF_INT;\n  C.setValue(address, node[0], \"i32\");\n}\n__name(marshalNode, \"marshalNode\");\nfunction unmarshalNode(tree, address = TRANSFER_BUFFER) {\n  const id = C.getValue(address, \"i32\");\n  address += SIZE_OF_INT;\n  if (id === 0) return null;\n  const index = C.getValue(address, \"i32\");\n  address += SIZE_OF_INT;\n  const row = C.getValue(address, \"i32\");\n  address += SIZE_OF_INT;\n  const column = C.getValue(address, \"i32\");\n  address += SIZE_OF_INT;\n  const other = C.getValue(address, \"i32\");\n  const result = new Node(INTERNAL, {\n    id,\n    tree,\n    startIndex: index,\n    startPosition: { row, column },\n    other\n  });\n  return result;\n}\n__name(unmarshalNode, \"unmarshalNode\");\nfunction marshalTreeCursor(cursor, address = TRANSFER_BUFFER) {\n  C.setValue(address + 0 * SIZE_OF_INT, cursor[0], \"i32\");\n  C.setValue(address + 1 * SIZE_OF_INT, cursor[1], \"i32\");\n  C.setValue(address + 2 * SIZE_OF_INT, cursor[2], \"i32\");\n  C.setValue(address + 3 * SIZE_OF_INT, cursor[3], \"i32\");\n}\n__name(marshalTreeCursor, \"marshalTreeCursor\");\nfunction unmarshalTreeCursor(cursor) {\n  cursor[0] = C.getValue(TRANSFER_BUFFER + 0 * SIZE_OF_INT, \"i32\");\n  cursor[1] = C.getValue(TRANSFER_BUFFER + 1 * SIZE_OF_INT, \"i32\");\n  cursor[2] = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, \"i32\");\n  cursor[3] = C.getValue(TRANSFER_BUFFER + 3 * SIZE_OF_INT, \"i32\");\n}\n__name(unmarshalTreeCursor, \"unmarshalTreeCursor\");\nfunction marshalPoint(address, point) {\n  C.setValue(address, point.row, \"i32\");\n  C.setValue(address + SIZE_OF_INT, point.column, \"i32\");\n}\n__name(marshalPoint, \"marshalPoint\");\nfunction unmarshalPoint(address) {\n  const result = {\n    row: C.getValue(address, \"i32\") >>> 0,\n    column: C.getValue(address + SIZE_OF_INT, \"i32\") >>> 0\n  };\n  return result;\n}\n__name(unmarshalPoint, \"unmarshalPoint\");\nfunction marshalRange(address, range) {\n  marshalPoint(address, range.startPosition);\n  address += SIZE_OF_POINT;\n  marshalPoint(address, range.endPosition);\n  address += SIZE_OF_POINT;\n  C.setValue(address, range.startIndex, \"i32\");\n  address += SIZE_OF_INT;\n  C.setValue(address, range.endIndex, \"i32\");\n  address += SIZE_OF_INT;\n}\n__name(marshalRange, \"marshalRange\");\nfunction unmarshalRange(address) {\n  const result = {};\n  result.startPosition = unmarshalPoint(address);\n  address += SIZE_OF_POINT;\n  result.endPosition = unmarshalPoint(address);\n  address += SIZE_OF_POINT;\n  result.startIndex = C.getValue(address, \"i32\") >>> 0;\n  address += SIZE_OF_INT;\n  result.endIndex = C.getValue(address, \"i32\") >>> 0;\n  return result;\n}\n__name(unmarshalRange, \"unmarshalRange\");\nfunction marshalEdit(edit, address = TRANSFER_BUFFER) {\n  marshalPoint(address, edit.startPosition);\n  address += SIZE_OF_POINT;\n  marshalPoint(address, edit.oldEndPosition);\n  address += SIZE_OF_POINT;\n  marshalPoint(address, edit.newEndPosition);\n  address += SIZE_OF_POINT;\n  C.setValue(address, edit.startIndex, \"i32\");\n  address += SIZE_OF_INT;\n  C.setValue(address, edit.oldEndIndex, \"i32\");\n  address += SIZE_OF_INT;\n  C.setValue(address, edit.newEndIndex, \"i32\");\n  address += SIZE_OF_INT;\n}\n__name(marshalEdit, \"marshalEdit\");\nfunction unmarshalLanguageMetadata(address) {\n  const major_version = C.getValue(address, \"i32\");\n  const minor_version = C.getValue(address += SIZE_OF_INT, \"i32\");\n  const patch_version = C.getValue(address += SIZE_OF_INT, \"i32\");\n  return { major_version, minor_version, patch_version };\n}\n__name(unmarshalLanguageMetadata, \"unmarshalLanguageMetadata\");\n\n// src/query.ts\nvar PREDICATE_STEP_TYPE_CAPTURE = 1;\nvar PREDICATE_STEP_TYPE_STRING = 2;\nvar QUERY_WORD_REGEX = /[\\w-]+/g;\nvar CaptureQuantifier = {\n  Zero: 0,\n  ZeroOrOne: 1,\n  ZeroOrMore: 2,\n  One: 3,\n  OneOrMore: 4\n};\nvar isCaptureStep = /* @__PURE__ */ __name((step) => step.type === \"capture\", \"isCaptureStep\");\nvar isStringStep = /* @__PURE__ */ __name((step) => step.type === \"string\", \"isStringStep\");\nvar QueryErrorKind = {\n  Syntax: 1,\n  NodeName: 2,\n  FieldName: 3,\n  CaptureName: 4,\n  PatternStructure: 5\n};\nvar QueryError = class _QueryError extends Error {\n  constructor(kind, info2, index, length) {\n    super(_QueryError.formatMessage(kind, info2));\n    this.kind = kind;\n    this.info = info2;\n    this.index = index;\n    this.length = length;\n    this.name = \"QueryError\";\n  }\n  static {\n    __name(this, \"QueryError\");\n  }\n  /** Formats an error message based on the error kind and info */\n  static formatMessage(kind, info2) {\n    switch (kind) {\n      case QueryErrorKind.NodeName:\n        return `Bad node name '${info2.word}'`;\n      case QueryErrorKind.FieldName:\n        return `Bad field name '${info2.word}'`;\n      case QueryErrorKind.CaptureName:\n        return `Bad capture name @${info2.word}`;\n      case QueryErrorKind.PatternStructure:\n        return `Bad pattern structure at offset ${info2.suffix}`;\n      case QueryErrorKind.Syntax:\n        return `Bad syntax at offset ${info2.suffix}`;\n    }\n  }\n};\nfunction parseAnyPredicate(steps, index, operator, textPredicates) {\n  if (steps.length !== 3) {\n    throw new Error(\n      `Wrong number of arguments to \\`#${operator}\\` predicate. Expected 2, got ${steps.length - 1}`\n    );\n  }\n  if (!isCaptureStep(steps[1])) {\n    throw new Error(\n      `First argument of \\`#${operator}\\` predicate must be a capture. Got \"${steps[1].value}\"`\n    );\n  }\n  const isPositive = operator === \"eq?\" || operator === \"any-eq?\";\n  const matchAll = !operator.startsWith(\"any-\");\n  if (isCaptureStep(steps[2])) {\n    const captureName1 = steps[1].name;\n    const captureName2 = steps[2].name;\n    textPredicates[index].push((captures) => {\n      const nodes1 = [];\n      const nodes2 = [];\n      for (const c of captures) {\n        if (c.name === captureName1) nodes1.push(c.node);\n        if (c.name === captureName2) nodes2.push(c.node);\n      }\n      const compare = /* @__PURE__ */ __name((n1, n2, positive) => {\n        return positive ? n1.text === n2.text : n1.text !== n2.text;\n      }, \"compare\");\n      return matchAll ? nodes1.every((n1) => nodes2.some((n2) => compare(n1, n2, isPositive))) : nodes1.some((n1) => nodes2.some((n2) => compare(n1, n2, isPositive)));\n    });\n  } else {\n    const captureName = steps[1].name;\n    const stringValue = steps[2].value;\n    const matches = /* @__PURE__ */ __name((n) => n.text === stringValue, \"matches\");\n    const doesNotMatch = /* @__PURE__ */ __name((n) => n.text !== stringValue, \"doesNotMatch\");\n    textPredicates[index].push((captures) => {\n      const nodes = [];\n      for (const c of captures) {\n        if (c.name === captureName) nodes.push(c.node);\n      }\n      const test = isPositive ? matches : doesNotMatch;\n      return matchAll ? nodes.every(test) : nodes.some(test);\n    });\n  }\n}\n__name(parseAnyPredicate, \"parseAnyPredicate\");\nfunction parseMatchPredicate(steps, index, operator, textPredicates) {\n  if (steps.length !== 3) {\n    throw new Error(\n      `Wrong number of arguments to \\`#${operator}\\` predicate. Expected 2, got ${steps.length - 1}.`\n    );\n  }\n  if (steps[1].type !== \"capture\") {\n    throw new Error(\n      `First argument of \\`#${operator}\\` predicate must be a capture. Got \"${steps[1].value}\".`\n    );\n  }\n  if (steps[2].type !== \"string\") {\n    throw new Error(\n      `Second argument of \\`#${operator}\\` predicate must be a string. Got @${steps[2].name}.`\n    );\n  }\n  const isPositive = operator === \"match?\" || operator === \"any-match?\";\n  const matchAll = !operator.startsWith(\"any-\");\n  const captureName = steps[1].name;\n  const regex = new RegExp(steps[2].value);\n  textPredicates[index].push((captures) => {\n    const nodes = [];\n    for (const c of captures) {\n      if (c.name === captureName) nodes.push(c.node.text);\n    }\n    const test = /* @__PURE__ */ __name((text, positive) => {\n      return positive ? regex.test(text) : !regex.test(text);\n    }, \"test\");\n    if (nodes.length === 0) return !isPositive;\n    return matchAll ? nodes.every((text) => test(text, isPositive)) : nodes.some((text) => test(text, isPositive));\n  });\n}\n__name(parseMatchPredicate, \"parseMatchPredicate\");\nfunction parseAnyOfPredicate(steps, index, operator, textPredicates) {\n  if (steps.length < 2) {\n    throw new Error(\n      `Wrong number of arguments to \\`#${operator}\\` predicate. Expected at least 1. Got ${steps.length - 1}.`\n    );\n  }\n  if (steps[1].type !== \"capture\") {\n    throw new Error(\n      `First argument of \\`#${operator}\\` predicate must be a capture. Got \"${steps[1].value}\".`\n    );\n  }\n  const isPositive = operator === \"any-of?\";\n  const captureName = steps[1].name;\n  const stringSteps = steps.slice(2);\n  if (!stringSteps.every(isStringStep)) {\n    throw new Error(\n      `Arguments to \\`#${operator}\\` predicate must be strings.\".`\n    );\n  }\n  const values = stringSteps.map((s) => s.value);\n  textPredicates[index].push((captures) => {\n    const nodes = [];\n    for (const c of captures) {\n      if (c.name === captureName) nodes.push(c.node.text);\n    }\n    if (nodes.length === 0) return !isPositive;\n    return nodes.every((text) => values.includes(text)) === isPositive;\n  });\n}\n__name(parseAnyOfPredicate, \"parseAnyOfPredicate\");\nfunction parseIsPredicate(steps, index, operator, assertedProperties, refutedProperties) {\n  if (steps.length < 2 || steps.length > 3) {\n    throw new Error(\n      `Wrong number of arguments to \\`#${operator}\\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`\n    );\n  }\n  if (!steps.every(isStringStep)) {\n    throw new Error(\n      `Arguments to \\`#${operator}\\` predicate must be strings.\".`\n    );\n  }\n  const properties = operator === \"is?\" ? assertedProperties : refutedProperties;\n  if (!properties[index]) properties[index] = {};\n  properties[index][steps[1].value] = steps[2]?.value ?? null;\n}\n__name(parseIsPredicate, \"parseIsPredicate\");\nfunction parseSetDirective(steps, index, setProperties) {\n  if (steps.length < 2 || steps.length > 3) {\n    throw new Error(`Wrong number of arguments to \\`#set!\\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`);\n  }\n  if (!steps.every(isStringStep)) {\n    throw new Error(`Arguments to \\`#set!\\` predicate must be strings.\".`);\n  }\n  if (!setProperties[index]) setProperties[index] = {};\n  setProperties[index][steps[1].value] = steps[2]?.value ?? null;\n}\n__name(parseSetDirective, \"parseSetDirective\");\nfunction parsePattern(index, stepType, stepValueId, captureNames, stringValues, steps, textPredicates, predicates, setProperties, assertedProperties, refutedProperties) {\n  if (stepType === PREDICATE_STEP_TYPE_CAPTURE) {\n    const name2 = captureNames[stepValueId];\n    steps.push({ type: \"capture\", name: name2 });\n  } else if (stepType === PREDICATE_STEP_TYPE_STRING) {\n    steps.push({ type: \"string\", value: stringValues[stepValueId] });\n  } else if (steps.length > 0) {\n    if (steps[0].type !== \"string\") {\n      throw new Error(\"Predicates must begin with a literal value\");\n    }\n    const operator = steps[0].value;\n    switch (operator) {\n      case \"any-not-eq?\":\n      case \"not-eq?\":\n      case \"any-eq?\":\n      case \"eq?\":\n        parseAnyPredicate(steps, index, operator, textPredicates);\n        break;\n      case \"any-not-match?\":\n      case \"not-match?\":\n      case \"any-match?\":\n      case \"match?\":\n        parseMatchPredicate(steps, index, operator, textPredicates);\n        break;\n      case \"not-any-of?\":\n      case \"any-of?\":\n        parseAnyOfPredicate(steps, index, operator, textPredicates);\n        break;\n      case \"is?\":\n      case \"is-not?\":\n        parseIsPredicate(steps, index, operator, assertedProperties, refutedProperties);\n        break;\n      case \"set!\":\n        parseSetDirective(steps, index, setProperties);\n        break;\n      default:\n        predicates[index].push({ operator, operands: steps.slice(1) });\n    }\n    steps.length = 0;\n  }\n}\n__name(parsePattern, \"parsePattern\");\nvar Query = class {\n  static {\n    __name(this, \"Query\");\n  }\n  /** @internal */\n  [0] = 0;\n  // Internal handle for WASM\n  /** @internal */\n  exceededMatchLimit;\n  /** @internal */\n  textPredicates;\n  /** The names of the captures used in the query. */\n  captureNames;\n  /** The quantifiers of the captures used in the query. */\n  captureQuantifiers;\n  /**\n   * The other user-defined predicates associated with the given index.\n   *\n   * This includes predicates with operators other than:\n   * - `match?`\n   * - `eq?` and `not-eq?`\n   * - `any-of?` and `not-any-of?`\n   * - `is?` and `is-not?`\n   * - `set!`\n   */\n  predicates;\n  /** The properties for predicates with the operator `set!`. */\n  setProperties;\n  /** The properties for predicates with the operator `is?`. */\n  assertedProperties;\n  /** The properties for predicates with the operator `is-not?`. */\n  refutedProperties;\n  /** The maximum number of in-progress matches for this cursor. */\n  matchLimit;\n  /**\n   * Create a new query from a string containing one or more S-expression\n   * patterns.\n   *\n   * The query is associated with a particular language, and can only be run\n   * on syntax nodes parsed with that language. References to Queries can be\n   * shared between multiple threads.\n   *\n   * @link {@see https://tree-sitter.github.io/tree-sitter/using-parsers/queries}\n   */\n  constructor(language, source) {\n    const sourceLength = C.lengthBytesUTF8(source);\n    const sourceAddress = C._malloc(sourceLength + 1);\n    C.stringToUTF8(source, sourceAddress, sourceLength + 1);\n    const address = C._ts_query_new(\n      language[0],\n      sourceAddress,\n      sourceLength,\n      TRANSFER_BUFFER,\n      TRANSFER_BUFFER + SIZE_OF_INT\n    );\n    if (!address) {\n      const errorId = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n      const errorByte = C.getValue(TRANSFER_BUFFER, \"i32\");\n      const errorIndex = C.UTF8ToString(sourceAddress, errorByte).length;\n      const suffix = source.slice(errorIndex, errorIndex + 100).split(\"\\n\")[0];\n      const word = suffix.match(QUERY_WORD_REGEX)?.[0] ?? \"\";\n      C._free(sourceAddress);\n      switch (errorId) {\n        case QueryErrorKind.Syntax:\n          throw new QueryError(QueryErrorKind.Syntax, { suffix: `${errorIndex}: '${suffix}'...` }, errorIndex, 0);\n        case QueryErrorKind.NodeName:\n          throw new QueryError(errorId, { word }, errorIndex, word.length);\n        case QueryErrorKind.FieldName:\n          throw new QueryError(errorId, { word }, errorIndex, word.length);\n        case QueryErrorKind.CaptureName:\n          throw new QueryError(errorId, { word }, errorIndex, word.length);\n        case QueryErrorKind.PatternStructure:\n          throw new QueryError(errorId, { suffix: `${errorIndex}: '${suffix}'...` }, errorIndex, 0);\n      }\n    }\n    const stringCount = C._ts_query_string_count(address);\n    const captureCount = C._ts_query_capture_count(address);\n    const patternCount = C._ts_query_pattern_count(address);\n    const captureNames = new Array(captureCount);\n    const captureQuantifiers = new Array(patternCount);\n    const stringValues = new Array(stringCount);\n    for (let i2 = 0; i2 < captureCount; i2++) {\n      const nameAddress = C._ts_query_capture_name_for_id(\n        address,\n        i2,\n        TRANSFER_BUFFER\n      );\n      const nameLength = C.getValue(TRANSFER_BUFFER, \"i32\");\n      captureNames[i2] = C.UTF8ToString(nameAddress, nameLength);\n    }\n    for (let i2 = 0; i2 < patternCount; i2++) {\n      const captureQuantifiersArray = new Array(captureCount);\n      for (let j = 0; j < captureCount; j++) {\n        const quantifier = C._ts_query_capture_quantifier_for_id(address, i2, j);\n        captureQuantifiersArray[j] = quantifier;\n      }\n      captureQuantifiers[i2] = captureQuantifiersArray;\n    }\n    for (let i2 = 0; i2 < stringCount; i2++) {\n      const valueAddress = C._ts_query_string_value_for_id(\n        address,\n        i2,\n        TRANSFER_BUFFER\n      );\n      const nameLength = C.getValue(TRANSFER_BUFFER, \"i32\");\n      stringValues[i2] = C.UTF8ToString(valueAddress, nameLength);\n    }\n    const setProperties = new Array(patternCount);\n    const assertedProperties = new Array(patternCount);\n    const refutedProperties = new Array(patternCount);\n    const predicates = new Array(patternCount);\n    const textPredicates = new Array(patternCount);\n    for (let i2 = 0; i2 < patternCount; i2++) {\n      const predicatesAddress = C._ts_query_predicates_for_pattern(address, i2, TRANSFER_BUFFER);\n      const stepCount = C.getValue(TRANSFER_BUFFER, \"i32\");\n      predicates[i2] = [];\n      textPredicates[i2] = [];\n      const steps = new Array();\n      let stepAddress = predicatesAddress;\n      for (let j = 0; j < stepCount; j++) {\n        const stepType = C.getValue(stepAddress, \"i32\");\n        stepAddress += SIZE_OF_INT;\n        const stepValueId = C.getValue(stepAddress, \"i32\");\n        stepAddress += SIZE_OF_INT;\n        parsePattern(\n          i2,\n          stepType,\n          stepValueId,\n          captureNames,\n          stringValues,\n          steps,\n          textPredicates,\n          predicates,\n          setProperties,\n          assertedProperties,\n          refutedProperties\n        );\n      }\n      Object.freeze(textPredicates[i2]);\n      Object.freeze(predicates[i2]);\n      Object.freeze(setProperties[i2]);\n      Object.freeze(assertedProperties[i2]);\n      Object.freeze(refutedProperties[i2]);\n    }\n    C._free(sourceAddress);\n    this[0] = address;\n    this.captureNames = captureNames;\n    this.captureQuantifiers = captureQuantifiers;\n    this.textPredicates = textPredicates;\n    this.predicates = predicates;\n    this.setProperties = setProperties;\n    this.assertedProperties = assertedProperties;\n    this.refutedProperties = refutedProperties;\n    this.exceededMatchLimit = false;\n  }\n  /** Delete the query, freeing its resources. */\n  delete() {\n    C._ts_query_delete(this[0]);\n    this[0] = 0;\n  }\n  /**\n   * Iterate over all of the matches in the order that they were found.\n   *\n   * Each match contains the index of the pattern that matched, and a list of\n   * captures. Because multiple patterns can match the same set of nodes,\n   * one match may contain captures that appear *before* some of the\n   * captures from a previous match.\n   *\n   * @param {Node} node - The node to execute the query on.\n   *\n   * @param {QueryOptions} options - Options for query execution.\n   */\n  matches(node, options = {}) {\n    const startPosition = options.startPosition ?? ZERO_POINT;\n    const endPosition = options.endPosition ?? ZERO_POINT;\n    const startIndex = options.startIndex ?? 0;\n    const endIndex = options.endIndex ?? 0;\n    const matchLimit = options.matchLimit ?? 4294967295;\n    const maxStartDepth = options.maxStartDepth ?? 4294967295;\n    const timeoutMicros = options.timeoutMicros ?? 0;\n    const progressCallback = options.progressCallback;\n    if (typeof matchLimit !== \"number\") {\n      throw new Error(\"Arguments must be numbers\");\n    }\n    this.matchLimit = matchLimit;\n    if (endIndex !== 0 && startIndex > endIndex) {\n      throw new Error(\"`startIndex` cannot be greater than `endIndex`\");\n    }\n    if (endPosition !== ZERO_POINT && (startPosition.row > endPosition.row || startPosition.row === endPosition.row && startPosition.column > endPosition.column)) {\n      throw new Error(\"`startPosition` cannot be greater than `endPosition`\");\n    }\n    if (progressCallback) {\n      C.currentQueryProgressCallback = progressCallback;\n    }\n    marshalNode(node);\n    C._ts_query_matches_wasm(\n      this[0],\n      node.tree[0],\n      startPosition.row,\n      startPosition.column,\n      endPosition.row,\n      endPosition.column,\n      startIndex,\n      endIndex,\n      matchLimit,\n      maxStartDepth,\n      timeoutMicros\n    );\n    const rawCount = C.getValue(TRANSFER_BUFFER, \"i32\");\n    const startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n    const didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, \"i32\");\n    const result = new Array(rawCount);\n    this.exceededMatchLimit = Boolean(didExceedMatchLimit);\n    let filteredCount = 0;\n    let address = startAddress;\n    for (let i2 = 0; i2 < rawCount; i2++) {\n      const patternIndex = C.getValue(address, \"i32\");\n      address += SIZE_OF_INT;\n      const captureCount = C.getValue(address, \"i32\");\n      address += SIZE_OF_INT;\n      const captures = new Array(captureCount);\n      address = unmarshalCaptures(this, node.tree, address, patternIndex, captures);\n      if (this.textPredicates[patternIndex].every((p) => p(captures))) {\n        result[filteredCount] = { pattern: patternIndex, patternIndex, captures };\n        const setProperties = this.setProperties[patternIndex];\n        result[filteredCount].setProperties = setProperties;\n        const assertedProperties = this.assertedProperties[patternIndex];\n        result[filteredCount].assertedProperties = assertedProperties;\n        const refutedProperties = this.refutedProperties[patternIndex];\n        result[filteredCount].refutedProperties = refutedProperties;\n        filteredCount++;\n      }\n    }\n    result.length = filteredCount;\n    C._free(startAddress);\n    C.currentQueryProgressCallback = null;\n    return result;\n  }\n  /**\n   * Iterate over all of the individual captures in the order that they\n   * appear.\n   *\n   * This is useful if you don't care about which pattern matched, and just\n   * want a single, ordered sequence of captures.\n   *\n   * @param {Node} node - The node to execute the query on.\n   *\n   * @param {QueryOptions} options - Options for query execution.\n   */\n  captures(node, options = {}) {\n    const startPosition = options.startPosition ?? ZERO_POINT;\n    const endPosition = options.endPosition ?? ZERO_POINT;\n    const startIndex = options.startIndex ?? 0;\n    const endIndex = options.endIndex ?? 0;\n    const matchLimit = options.matchLimit ?? 4294967295;\n    const maxStartDepth = options.maxStartDepth ?? 4294967295;\n    const timeoutMicros = options.timeoutMicros ?? 0;\n    const progressCallback = options.progressCallback;\n    if (typeof matchLimit !== \"number\") {\n      throw new Error(\"Arguments must be numbers\");\n    }\n    this.matchLimit = matchLimit;\n    if (endIndex !== 0 && startIndex > endIndex) {\n      throw new Error(\"`startIndex` cannot be greater than `endIndex`\");\n    }\n    if (endPosition !== ZERO_POINT && (startPosition.row > endPosition.row || startPosition.row === endPosition.row && startPosition.column > endPosition.column)) {\n      throw new Error(\"`startPosition` cannot be greater than `endPosition`\");\n    }\n    if (progressCallback) {\n      C.currentQueryProgressCallback = progressCallback;\n    }\n    marshalNode(node);\n    C._ts_query_captures_wasm(\n      this[0],\n      node.tree[0],\n      startPosition.row,\n      startPosition.column,\n      endPosition.row,\n      endPosition.column,\n      startIndex,\n      endIndex,\n      matchLimit,\n      maxStartDepth,\n      timeoutMicros\n    );\n    const count = C.getValue(TRANSFER_BUFFER, \"i32\");\n    const startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n    const didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, \"i32\");\n    const result = new Array();\n    this.exceededMatchLimit = Boolean(didExceedMatchLimit);\n    const captures = new Array();\n    let address = startAddress;\n    for (let i2 = 0; i2 < count; i2++) {\n      const patternIndex = C.getValue(address, \"i32\");\n      address += SIZE_OF_INT;\n      const captureCount = C.getValue(address, \"i32\");\n      address += SIZE_OF_INT;\n      const captureIndex = C.getValue(address, \"i32\");\n      address += SIZE_OF_INT;\n      captures.length = captureCount;\n      address = unmarshalCaptures(this, node.tree, address, patternIndex, captures);\n      if (this.textPredicates[patternIndex].every((p) => p(captures))) {\n        const capture = captures[captureIndex];\n        const setProperties = this.setProperties[patternIndex];\n        capture.setProperties = setProperties;\n        const assertedProperties = this.assertedProperties[patternIndex];\n        capture.assertedProperties = assertedProperties;\n        const refutedProperties = this.refutedProperties[patternIndex];\n        capture.refutedProperties = refutedProperties;\n        result.push(capture);\n      }\n    }\n    C._free(startAddress);\n    C.currentQueryProgressCallback = null;\n    return result;\n  }\n  /** Get the predicates for a given pattern. */\n  predicatesForPattern(patternIndex) {\n    return this.predicates[patternIndex];\n  }\n  /**\n   * Disable a certain capture within a query.\n   *\n   * This prevents the capture from being returned in matches, and also\n   * avoids any resource usage associated with recording the capture.\n   */\n  disableCapture(captureName) {\n    const captureNameLength = C.lengthBytesUTF8(captureName);\n    const captureNameAddress = C._malloc(captureNameLength + 1);\n    C.stringToUTF8(captureName, captureNameAddress, captureNameLength + 1);\n    C._ts_query_disable_capture(this[0], captureNameAddress, captureNameLength);\n    C._free(captureNameAddress);\n  }\n  /**\n   * Disable a certain pattern within a query.\n   *\n   * This prevents the pattern from matching, and also avoids any resource\n   * usage associated with the pattern. This throws an error if the pattern\n   * index is out of bounds.\n   */\n  disablePattern(patternIndex) {\n    if (patternIndex >= this.predicates.length) {\n      throw new Error(\n        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`\n      );\n    }\n    C._ts_query_disable_pattern(this[0], patternIndex);\n  }\n  /**\n   * Check if, on its last execution, this cursor exceeded its maximum number\n   * of in-progress matches.\n   */\n  didExceedMatchLimit() {\n    return this.exceededMatchLimit;\n  }\n  /** Get the byte offset where the given pattern starts in the query's source. */\n  startIndexForPattern(patternIndex) {\n    if (patternIndex >= this.predicates.length) {\n      throw new Error(\n        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`\n      );\n    }\n    return C._ts_query_start_byte_for_pattern(this[0], patternIndex);\n  }\n  /** Get the byte offset where the given pattern ends in the query's source. */\n  endIndexForPattern(patternIndex) {\n    if (patternIndex >= this.predicates.length) {\n      throw new Error(\n        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`\n      );\n    }\n    return C._ts_query_end_byte_for_pattern(this[0], patternIndex);\n  }\n  /** Get the number of patterns in the query. */\n  patternCount() {\n    return C._ts_query_pattern_count(this[0]);\n  }\n  /** Get the index for a given capture name. */\n  captureIndexForName(captureName) {\n    return this.captureNames.indexOf(captureName);\n  }\n  /** Check if a given pattern within a query has a single root node. */\n  isPatternRooted(patternIndex) {\n    return C._ts_query_is_pattern_rooted(this[0], patternIndex) === 1;\n  }\n  /** Check if a given pattern within a query has a single root node. */\n  isPatternNonLocal(patternIndex) {\n    return C._ts_query_is_pattern_non_local(this[0], patternIndex) === 1;\n  }\n  /**\n   * Check if a given step in a query is 'definite'.\n   *\n   * A query step is 'definite' if its parent pattern will be guaranteed to\n   * match successfully once it reaches the step.\n   */\n  isPatternGuaranteedAtStep(byteIndex) {\n    return C._ts_query_is_pattern_guaranteed_at_step(this[0], byteIndex) === 1;\n  }\n};\n\n// src/language.ts\nvar LANGUAGE_FUNCTION_REGEX = /^tree_sitter_\\w+$/;\nvar Language = class _Language {\n  static {\n    __name(this, \"Language\");\n  }\n  /** @internal */\n  [0] = 0;\n  // Internal handle for WASM\n  /**\n   * A list of all node types in the language. The index of each type in this\n   * array is its node type id.\n   */\n  types;\n  /**\n   * A list of all field names in the language. The index of each field name in\n   * this array is its field id.\n   */\n  fields;\n  /** @internal */\n  constructor(internal, address) {\n    assertInternal(internal);\n    this[0] = address;\n    this.types = new Array(C._ts_language_symbol_count(this[0]));\n    for (let i2 = 0, n = this.types.length; i2 < n; i2++) {\n      if (C._ts_language_symbol_type(this[0], i2) < 2) {\n        this.types[i2] = C.UTF8ToString(C._ts_language_symbol_name(this[0], i2));\n      }\n    }\n    this.fields = new Array(C._ts_language_field_count(this[0]) + 1);\n    for (let i2 = 0, n = this.fields.length; i2 < n; i2++) {\n      const fieldName = C._ts_language_field_name_for_id(this[0], i2);\n      if (fieldName !== 0) {\n        this.fields[i2] = C.UTF8ToString(fieldName);\n      } else {\n        this.fields[i2] = null;\n      }\n    }\n  }\n  /**\n   * Gets the name of the language.\n   */\n  get name() {\n    const ptr = C._ts_language_name(this[0]);\n    if (ptr === 0) return null;\n    return C.UTF8ToString(ptr);\n  }\n  /**\n   * @deprecated since version 0.25.0, use {@link Language#abiVersion} instead\n   * Gets the version of the language.\n   */\n  get version() {\n    return C._ts_language_version(this[0]);\n  }\n  /**\n   * Gets the ABI version of the language.\n   */\n  get abiVersion() {\n    return C._ts_language_abi_version(this[0]);\n  }\n  /**\n  * Get the metadata for this language. This information is generated by the\n  * CLI, and relies on the language author providing the correct metadata in\n  * the language's `tree-sitter.json` file.\n  */\n  get metadata() {\n    C._ts_language_metadata(this[0]);\n    const length = C.getValue(TRANSFER_BUFFER, \"i32\");\n    const address = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n    if (length === 0) return null;\n    return unmarshalLanguageMetadata(address);\n  }\n  /**\n   * Gets the number of fields in the language.\n   */\n  get fieldCount() {\n    return this.fields.length - 1;\n  }\n  /**\n   * Gets the number of states in the language.\n   */\n  get stateCount() {\n    return C._ts_language_state_count(this[0]);\n  }\n  /**\n   * Get the field id for a field name.\n   */\n  fieldIdForName(fieldName) {\n    const result = this.fields.indexOf(fieldName);\n    return result !== -1 ? result : null;\n  }\n  /**\n   * Get the field name for a field id.\n   */\n  fieldNameForId(fieldId) {\n    return this.fields[fieldId] ?? null;\n  }\n  /**\n   * Get the node type id for a node type name.\n   */\n  idForNodeType(type, named) {\n    const typeLength = C.lengthBytesUTF8(type);\n    const typeAddress = C._malloc(typeLength + 1);\n    C.stringToUTF8(type, typeAddress, typeLength + 1);\n    const result = C._ts_language_symbol_for_name(this[0], typeAddress, typeLength, named ? 1 : 0);\n    C._free(typeAddress);\n    return result || null;\n  }\n  /**\n   * Gets the number of node types in the language.\n   */\n  get nodeTypeCount() {\n    return C._ts_language_symbol_count(this[0]);\n  }\n  /**\n   * Get the node type name for a node type id.\n   */\n  nodeTypeForId(typeId) {\n    const name2 = C._ts_language_symbol_name(this[0], typeId);\n    return name2 ? C.UTF8ToString(name2) : null;\n  }\n  /**\n   * Check if a node type is named.\n   *\n   * @see {@link https://tree-sitter.github.io/tree-sitter/using-parsers/2-basic-parsing.html#named-vs-anonymous-nodes}\n   */\n  nodeTypeIsNamed(typeId) {\n    return C._ts_language_type_is_named_wasm(this[0], typeId) ? true : false;\n  }\n  /**\n   * Check if a node type is visible.\n   */\n  nodeTypeIsVisible(typeId) {\n    return C._ts_language_type_is_visible_wasm(this[0], typeId) ? true : false;\n  }\n  /**\n   * Get the supertypes ids of this language.\n   *\n   * @see {@link https://tree-sitter.github.io/tree-sitter/using-parsers/6-static-node-types.html?highlight=supertype#supertype-nodes}\n   */\n  get supertypes() {\n    C._ts_language_supertypes_wasm(this[0]);\n    const count = C.getValue(TRANSFER_BUFFER, \"i32\");\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n    const result = new Array(count);\n    if (count > 0) {\n      let address = buffer;\n      for (let i2 = 0; i2 < count; i2++) {\n        result[i2] = C.getValue(address, \"i16\");\n        address += SIZE_OF_SHORT;\n      }\n    }\n    return result;\n  }\n  /**\n   * Get the subtype ids for a given supertype node id.\n   */\n  subtypes(supertype) {\n    C._ts_language_subtypes_wasm(this[0], supertype);\n    const count = C.getValue(TRANSFER_BUFFER, \"i32\");\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n    const result = new Array(count);\n    if (count > 0) {\n      let address = buffer;\n      for (let i2 = 0; i2 < count; i2++) {\n        result[i2] = C.getValue(address, \"i16\");\n        address += SIZE_OF_SHORT;\n      }\n    }\n    return result;\n  }\n  /**\n   * Get the next state id for a given state id and node type id.\n   */\n  nextState(stateId, typeId) {\n    return C._ts_language_next_state(this[0], stateId, typeId);\n  }\n  /**\n   * Create a new lookahead iterator for this language and parse state.\n   *\n   * This returns `null` if state is invalid for this language.\n   *\n   * Iterating {@link LookaheadIterator} will yield valid symbols in the given\n   * parse state. Newly created lookahead iterators will return the `ERROR`\n   * symbol from {@link LookaheadIterator#currentType}.\n   *\n   * Lookahead iterators can be useful for generating suggestions and improving\n   * syntax error diagnostics. To get symbols valid in an `ERROR` node, use the\n   * lookahead iterator on its first leaf node state. For `MISSING` nodes, a\n   * lookahead iterator created on the previous non-extra leaf node may be\n   * appropriate.\n   */\n  lookaheadIterator(stateId) {\n    const address = C._ts_lookahead_iterator_new(this[0], stateId);\n    if (address) return new LookaheadIterator(INTERNAL, address, this);\n    return null;\n  }\n  /**\n   * @deprecated since version 0.25.0, call `new` on a {@link Query} instead\n   *\n   * Create a new query from a string containing one or more S-expression\n   * patterns.\n   *\n   * The query is associated with a particular language, and can only be run\n   * on syntax nodes parsed with that language. References to Queries can be\n   * shared between multiple threads.\n   *\n   * @link {@see https://tree-sitter.github.io/tree-sitter/using-parsers/queries}\n   */\n  query(source) {\n    console.warn(\"Language.query is deprecated. Use new Query(language, source) instead.\");\n    return new Query(this, source);\n  }\n  /**\n   * Load a language from a WebAssembly module.\n   * The module can be provided as a path to a file or as a buffer.\n   */\n  static async load(input) {\n    let bytes;\n    if (input instanceof Uint8Array) {\n      bytes = Promise.resolve(input);\n    } else {\n      if (globalThis.process?.versions.node) {\n        const fs2 = await import(\"fs/promises\");\n        bytes = fs2.readFile(input);\n      } else {\n        bytes = fetch(input).then((response) => response.arrayBuffer().then((buffer) => {\n          if (response.ok) {\n            return new Uint8Array(buffer);\n          } else {\n            const body2 = new TextDecoder(\"utf-8\").decode(buffer);\n            throw new Error(`Language.load failed with status ${response.status}.\n\n${body2}`);\n          }\n        }));\n      }\n    }\n    const mod = await C.loadWebAssemblyModule(await bytes, { loadAsync: true });\n    const symbolNames = Object.keys(mod);\n    const functionName = symbolNames.find((key) => LANGUAGE_FUNCTION_REGEX.test(key) && !key.includes(\"external_scanner_\"));\n    if (!functionName) {\n      console.log(`Couldn't find language function in WASM file. Symbols:\n${JSON.stringify(symbolNames, null, 2)}`);\n      throw new Error(\"Language.load failed: no language function found in WASM file\");\n    }\n    const languageAddress = mod[functionName]();\n    return new _Language(INTERNAL, languageAddress);\n  }\n};\n\n// src/bindings.ts\nvar import_tree_sitter = __toESM(require_tree_sitter(), 1);\nvar Module2 = null;\nasync function initializeBinding(moduleOptions) {\n  if (!Module2) {\n    Module2 = await (0, import_tree_sitter.default)(moduleOptions);\n  }\n  return Module2;\n}\n__name(initializeBinding, \"initializeBinding\");\nfunction checkModule() {\n  return !!Module2;\n}\n__name(checkModule, \"checkModule\");\n\n// src/parser.ts\nvar TRANSFER_BUFFER;\nvar LANGUAGE_VERSION;\nvar MIN_COMPATIBLE_VERSION;\nvar Parser = class {\n  static {\n    __name(this, \"Parser\");\n  }\n  /** @internal */\n  [0] = 0;\n  // Internal handle for WASM\n  /** @internal */\n  [1] = 0;\n  // Internal handle for WASM\n  /** @internal */\n  logCallback = null;\n  /** The parser's current language. */\n  language = null;\n  /**\n   * This must always be called before creating a Parser.\n   *\n   * You can optionally pass in options to configure the WASM module, the most common\n   * one being `locateFile` to help the module find the `.wasm` file.\n   */\n  static async init(moduleOptions) {\n    setModule(await initializeBinding(moduleOptions));\n    TRANSFER_BUFFER = C._ts_init();\n    LANGUAGE_VERSION = C.getValue(TRANSFER_BUFFER, \"i32\");\n    MIN_COMPATIBLE_VERSION = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n  }\n  /**\n   * Create a new parser.\n   */\n  constructor() {\n    this.initialize();\n  }\n  /** @internal */\n  initialize() {\n    if (!checkModule()) {\n      throw new Error(\"cannot construct a Parser before calling `init()`\");\n    }\n    C._ts_parser_new_wasm();\n    this[0] = C.getValue(TRANSFER_BUFFER, \"i32\");\n    this[1] = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n  }\n  /** Delete the parser, freeing its resources. */\n  delete() {\n    C._ts_parser_delete(this[0]);\n    C._free(this[1]);\n    this[0] = 0;\n    this[1] = 0;\n  }\n  /**\n   * Set the language that the parser should use for parsing.\n   *\n   * If the language was not successfully assigned, an error will be thrown.\n   * This happens if the language was generated with an incompatible\n   * version of the Tree-sitter CLI. Check the language's version using\n   * {@link Language#version} and compare it to this library's\n   * {@link LANGUAGE_VERSION} and {@link MIN_COMPATIBLE_VERSION} constants.\n   */\n  setLanguage(language) {\n    let address;\n    if (!language) {\n      address = 0;\n      this.language = null;\n    } else if (language.constructor === Language) {\n      address = language[0];\n      const version = C._ts_language_version(address);\n      if (version < MIN_COMPATIBLE_VERSION || LANGUAGE_VERSION < version) {\n        throw new Error(\n          `Incompatible language version ${version}. Compatibility range ${MIN_COMPATIBLE_VERSION} through ${LANGUAGE_VERSION}.`\n        );\n      }\n      this.language = language;\n    } else {\n      throw new Error(\"Argument must be a Language\");\n    }\n    C._ts_parser_set_language(this[0], address);\n    return this;\n  }\n  /**\n   * Parse a slice of UTF8 text.\n   *\n   * @param {string | ParseCallback} callback - The UTF8-encoded text to parse or a callback function.\n   *\n   * @param {Tree | null} [oldTree] - A previous syntax tree parsed from the same document. If the text of the\n   *   document has changed since `oldTree` was created, then you must edit `oldTree` to match\n   *   the new text using {@link Tree#edit}.\n   *\n   * @param {ParseOptions} [options] - Options for parsing the text.\n   *  This can be used to set the included ranges, or a progress callback.\n   *\n   * @returns {Tree | null} A {@link Tree} if parsing succeeded, or `null` if:\n   *  - The parser has not yet had a language assigned with {@link Parser#setLanguage}.\n   *  - The progress callback returned true.\n   */\n  parse(callback, oldTree, options) {\n    if (typeof callback === \"string\") {\n      C.currentParseCallback = (index) => callback.slice(index);\n    } else if (typeof callback === \"function\") {\n      C.currentParseCallback = callback;\n    } else {\n      throw new Error(\"Argument must be a string or a function\");\n    }\n    if (options?.progressCallback) {\n      C.currentProgressCallback = options.progressCallback;\n    } else {\n      C.currentProgressCallback = null;\n    }\n    if (this.logCallback) {\n      C.currentLogCallback = this.logCallback;\n      C._ts_parser_enable_logger_wasm(this[0], 1);\n    } else {\n      C.currentLogCallback = null;\n      C._ts_parser_enable_logger_wasm(this[0], 0);\n    }\n    let rangeCount = 0;\n    let rangeAddress = 0;\n    if (options?.includedRanges) {\n      rangeCount = options.includedRanges.length;\n      rangeAddress = C._calloc(rangeCount, SIZE_OF_RANGE);\n      let address = rangeAddress;\n      for (let i2 = 0; i2 < rangeCount; i2++) {\n        marshalRange(address, options.includedRanges[i2]);\n        address += SIZE_OF_RANGE;\n      }\n    }\n    const treeAddress = C._ts_parser_parse_wasm(\n      this[0],\n      this[1],\n      oldTree ? oldTree[0] : 0,\n      rangeAddress,\n      rangeCount\n    );\n    if (!treeAddress) {\n      C.currentParseCallback = null;\n      C.currentLogCallback = null;\n      C.currentProgressCallback = null;\n      return null;\n    }\n    if (!this.language) {\n      throw new Error(\"Parser must have a language to parse\");\n    }\n    const result = new Tree(INTERNAL, treeAddress, this.language, C.currentParseCallback);\n    C.currentParseCallback = null;\n    C.currentLogCallback = null;\n    C.currentProgressCallback = null;\n    return result;\n  }\n  /**\n   * Instruct the parser to start the next parse from the beginning.\n   *\n   * If the parser previously failed because of a timeout, cancellation,\n   * or callback, then by default, it will resume where it left off on the\n   * next call to {@link Parser#parse} or other parsing functions.\n   * If you don't want to resume, and instead intend to use this parser to\n   * parse some other document, you must call `reset` first.\n   */\n  reset() {\n    C._ts_parser_reset(this[0]);\n  }\n  /** Get the ranges of text that the parser will include when parsing. */\n  getIncludedRanges() {\n    C._ts_parser_included_ranges_wasm(this[0]);\n    const count = C.getValue(TRANSFER_BUFFER, \"i32\");\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, \"i32\");\n    const result = new Array(count);\n    if (count > 0) {\n      let address = buffer;\n      for (let i2 = 0; i2 < count; i2++) {\n        result[i2] = unmarshalRange(address);\n        address += SIZE_OF_RANGE;\n      }\n      C._free(buffer);\n    }\n    return result;\n  }\n  /**\n   * @deprecated since version 0.25.0, prefer passing a progress callback to {@link Parser#parse}\n   *\n   * Get the duration in microseconds that parsing is allowed to take.\n   *\n   * This is set via {@link Parser#setTimeoutMicros}.\n   */\n  getTimeoutMicros() {\n    return C._ts_parser_timeout_micros(this[0]);\n  }\n  /**\n   * @deprecated since version 0.25.0, prefer passing a progress callback to {@link Parser#parse}\n   *\n   * Set the maximum duration in microseconds that parsing should be allowed\n   * to take before halting.\n   *\n   * If parsing takes longer than this, it will halt early, returning `null`.\n   * See {@link Parser#parse} for more information.\n   */\n  setTimeoutMicros(timeout) {\n    C._ts_parser_set_timeout_micros(this[0], 0, timeout);\n  }\n  /** Set the logging callback that a parser should use during parsing. */\n  setLogger(callback) {\n    if (!callback) {\n      this.logCallback = null;\n    } else if (typeof callback !== \"function\") {\n      throw new Error(\"Logger callback must be a function\");\n    } else {\n      this.logCallback = callback;\n    }\n    return this;\n  }\n  /** Get the parser's current logger. */\n  getLogger() {\n    return this.logCallback;\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  CaptureQuantifier,\n  LANGUAGE_VERSION,\n  Language,\n  LookaheadIterator,\n  MIN_COMPATIBLE_VERSION,\n  Node,\n  Parser,\n  Query,\n  Tree,\n  TreeCursor\n});\n//# sourceMappingURL=tree-sitter.cjs.map\n","import * as vscode from 'vscode';\nimport { Parser, Language } from 'web-tree-sitter';\nimport * as path from 'path';\n\nlet pythonParser: Parser | null = null;\n\n// Parse a Python file and return AST information\nasync function parsePythonFile(filePath: string): Promise<any> {\n    if (!pythonParser) {\n        throw new Error('Python parser not initialized');\n    }\n\n    try {\n        const document = await vscode.workspace.openTextDocument(filePath);\n        const sourceCode = document.getText();\n\n        const tree = pythonParser.parse(sourceCode);\n        if (!tree) {\n            throw new Error('Failed to parse source code');\n        }\n\n        // Extract useful information from the AST\n        const functions: any[] = [];\n        const classes: any[] = [];\n        const imports: any[] = [];\n\n        // Walk the tree to find interesting nodes\n        const walkTree = (node: any, depth = 0) => {\n            if (node.type === 'function_definition') {\n                const functionName = node.childForFieldName('name')?.text;\n                functions.push({\n                    name: functionName,\n                    start: node.startPosition,\n                    end: node.endPosition\n                });\n            } else if (node.type === 'class_definition') {\n                const className = node.childForFieldName('name')?.text;\n                classes.push({\n                    name: className,\n                    start: node.startPosition,\n                    end: node.endPosition\n                });\n            } else if (node.type === 'import_statement' || node.type === 'import_from_statement') {\n                imports.push({\n                    text: node.text,\n                    start: node.startPosition,\n                    end: node.endPosition\n                });\n            }\n\n            // Recursively walk children\n            for (let i = 0; i < node.childCount; i++) {\n                walkTree(node.child(i), depth + 1);\n            }\n        };\n\n        walkTree(tree.rootNode);\n\n        return {\n            filePath,\n            tree: tree.rootNode.toString(),\n            functions,\n            classes,\n            imports,\n            totalNodes: countNodes(tree.rootNode)\n        };\n    } catch (error) {\n        console.error('Error parsing Python file:', error);\n        throw error;\n    }\n}\n\n// Helper function to count total nodes in tree\nfunction countNodes(node: any): number {\n    let count = 1; // count this node\n    for (let i = 0; i < node.childCount; i++) {\n        count += countNodes(node.child(i));\n    }\n    return count;\n}\n\n// Parse all Python files in workspace\nasync function parseAllPythonFiles(): Promise<any[]> {\n    const pythonFiles = await vscode.workspace.findFiles('**/*.py', '**/node_modules/**');\n    const results: any[] = [];\n\n    for (const file of pythonFiles) {\n        try {\n            const result = await parsePythonFile(file.fsPath);\n            results.push(result);\n        } catch (error) {\n            console.error(`Failed to parse ${file.fsPath}:`, error);\n        }\n    }\n\n    return results;\n}\n\n// Save parsing results to output files\nasync function saveParsingResults(results: any[]): Promise<void> {\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    if (!workspaceFolder) {\n        throw new Error('No workspace folder found');\n    }\n\n    // Create output directory\n    const outputDir = vscode.Uri.joinPath(workspaceFolder.uri, '.badger-index');\n    await vscode.workspace.fs.createDirectory(outputDir);\n\n    // Save individual file results\n    const filesDir = vscode.Uri.joinPath(outputDir, 'files');\n    await vscode.workspace.fs.createDirectory(filesDir);\n\n    for (const result of results) {\n        const fileName = path.basename(result.filePath, '.py') + '.json';\n        const fileUri = vscode.Uri.joinPath(filesDir, fileName);\n        const content = JSON.stringify(result, null, 2);\n        await vscode.workspace.fs.writeFile(fileUri, Buffer.from(content, 'utf8'));\n    }\n\n    // Save summary index\n    const summary = {\n        generatedAt: new Date().toISOString(),\n        totalFiles: results.length,\n        totalFunctions: results.reduce((sum, r) => sum + r.functions.length, 0),\n        totalClasses: results.reduce((sum, r) => sum + r.classes.length, 0),\n        totalImports: results.reduce((sum, r) => sum + r.imports.length, 0),\n        files: results.map(r => ({\n            path: r.filePath,\n            functions: r.functions.length,\n            classes: r.classes.length,\n            imports: r.imports.length,\n            astNodes: r.totalNodes\n        }))\n    };\n\n    const summaryUri = vscode.Uri.joinPath(outputDir, 'index.json');\n    await vscode.workspace.fs.writeFile(summaryUri, Buffer.from(JSON.stringify(summary, null, 2), 'utf8'));\n\n    // Save semantic relationships\n    const relationships = extractSemanticRelationships(results);\n    const relationshipsUri = vscode.Uri.joinPath(outputDir, 'relationships.json');\n    await vscode.workspace.fs.writeFile(relationshipsUri, Buffer.from(JSON.stringify(relationships, null, 2), 'utf8'));\n}\n\n// Extract semantic relationships from parsed files\nfunction extractSemanticRelationships(results: any[]): any {\n    const relationships = {\n        generatedAt: new Date().toISOString(),\n        functions: [] as any[],\n        classes: [] as any[],\n        imports: [] as any[],\n        calls: [] as any[]\n    };\n\n    for (const result of results) {\n        const filePath = result.filePath;\n\n        // Collect functions\n        for (const func of result.functions) {\n            relationships.functions.push({\n                name: func.name,\n                file: filePath,\n                line: func.start.row + 1,\n                column: func.start.column\n            });\n        }\n\n        // Collect classes\n        for (const cls of result.classes) {\n            relationships.classes.push({\n                name: cls.name,\n                file: filePath,\n                line: cls.start.row + 1,\n                column: cls.start.column\n            });\n        }\n\n        // Collect imports\n        for (const imp of result.imports) {\n            relationships.imports.push({\n                module: imp.text.trim(),\n                file: filePath,\n                line: imp.start.row + 1\n            });\n        }\n    }\n\n    return relationships;\n}\n\nexport async function activate(context: vscode.ExtensionContext) {\n    console.log(' Badger extension activation started');\n\n    try {\n        // Initialize tree-sitter parser\n        console.log('Initializing tree-sitter parser...');\n\n        // For VSCode extensions, we need to read the WASM files as Uint8Array\n        const treeSitterWasmUri = vscode.Uri.joinPath(context.extensionUri, 'out', 'tree-sitter.wasm');\n        const pythonWasmUri = vscode.Uri.joinPath(context.extensionUri, 'out', 'tree-sitter-python.wasm');\n\n        console.log(`Tree-sitter WASM URI: ${treeSitterWasmUri.toString()}`);\n        console.log(`Python WASM URI: ${pythonWasmUri.toString()}`);\n\n        // Read the WASM files\n        const treeSitterWasmData = await vscode.workspace.fs.readFile(treeSitterWasmUri);\n        const pythonWasmData = await vscode.workspace.fs.readFile(pythonWasmUri);\n\n        console.log(`Tree-sitter WASM loaded: ${treeSitterWasmData.length} bytes`);\n        console.log(`Python WASM loaded: ${pythonWasmData.length} bytes`);\n\n        await Parser.init({\n            locateFile(scriptName: string, scriptDirectory: string) {\n                console.log(`locateFile called for: ${scriptName}`);\n                // Return the URI as string - web-tree-sitter will handle the conversion\n                if (scriptName === 'tree-sitter.wasm') {\n                    return treeSitterWasmUri.toString();\n                }\n                return scriptName;\n            }\n        });\n\n        // Load Python language using the data directly\n        console.log('Loading Python language...');\n        const Python = await Language.load(pythonWasmData);\n\n        pythonParser = new Parser();\n        pythonParser.setLanguage(Python);\n\n        console.log(' Tree-sitter Python parser initialized successfully');\n    } catch (error) {\n        console.error(' Failed to initialize tree-sitter parser:', error);\n        vscode.window.showErrorMessage('Failed to initialize tree-sitter parser: ' + error);\n        // Continue with activation even if parser fails\n    }\n\n    console.log(' Registering Badger commands...');\n\n    // Register the index workspace command\n    const indexWorkspaceCommand = vscode.commands.registerCommand('badger.indexWorkspace', async () => {\n        if (!pythonParser) {\n            vscode.window.showErrorMessage('Tree-sitter parser not initialized');\n            return;\n        }\n\n        vscode.window.showInformationMessage('Indexing workspace with tree-sitter...');\n\n        try {\n            const results = await parseAllPythonFiles();\n            console.log('Parsed files:', results);\n\n            // Save results to files\n            await saveParsingResults(results);\n\n            const totalFiles = results.length;\n            const totalFunctions = results.reduce((sum, r) => sum + r.functions.length, 0);\n            const totalClasses = results.reduce((sum, r) => sum + r.classes.length, 0);\n\n            vscode.window.showInformationMessage(\n                `Indexed ${totalFiles} Python files: ${totalFunctions} functions, ${totalClasses} classes. Results saved to .badger-index/`\n            );\n\n            // TODO: Store in Dgraph database\n        } catch (error) {\n            vscode.window.showErrorMessage('Failed to index workspace: ' + error);\n        }\n    });\n\n    // Register the parse current file command\n    const parseCurrentFileCommand = vscode.commands.registerCommand('badger.parseCurrentFile', async () => {\n        if (!pythonParser) {\n            vscode.window.showErrorMessage('Tree-sitter parser not initialized');\n            return;\n        }\n\n        const activeEditor = vscode.window.activeTextEditor;\n        if (!activeEditor || !activeEditor.document.fileName.endsWith('.py')) {\n            vscode.window.showErrorMessage('Please open a Python file to parse');\n            return;\n        }\n\n        try {\n            vscode.window.showInformationMessage('Parsing current Python file...');\n\n            const result = await parsePythonFile(activeEditor.document.fileName);\n            console.log('Parsed file:', result);\n\n            // Show results in a new document\n            const outputChannel = vscode.window.createOutputChannel('Badger Parser');\n            outputChannel.clear();\n            outputChannel.appendLine(`=== Parsed: ${result.filePath} ===`);\n            outputChannel.appendLine(`Total AST nodes: ${result.totalNodes}`);\n            outputChannel.appendLine(`Functions found: ${result.functions.length}`);\n            outputChannel.appendLine(`Classes found: ${result.classes.length}`);\n            outputChannel.appendLine(`Imports found: ${result.imports.length}`);\n            outputChannel.appendLine('');\n\n            if (result.functions.length > 0) {\n                outputChannel.appendLine('Functions:');\n                result.functions.forEach((fn: any) => {\n                    outputChannel.appendLine(`  - ${fn.name} (line ${fn.start.row + 1})`);\n                });\n                outputChannel.appendLine('');\n            }\n\n            if (result.classes.length > 0) {\n                outputChannel.appendLine('Classes:');\n                result.classes.forEach((cls: any) => {\n                    outputChannel.appendLine(`  - ${cls.name} (line ${cls.start.row + 1})`);\n                });\n                outputChannel.appendLine('');\n            }\n\n            if (result.imports.length > 0) {\n                outputChannel.appendLine('Imports:');\n                result.imports.forEach((imp: any) => {\n                    outputChannel.appendLine(`  - ${imp.text.trim()}`);\n                });\n            }\n\n            outputChannel.show();\n\n            vscode.window.showInformationMessage(\n                `Parsed ${result.functions.length} functions, ${result.classes.length} classes`\n            );\n        } catch (error) {\n            vscode.window.showErrorMessage('Failed to parse current file: ' + error);\n        }\n    });\n\n    // Register the query context command\n    const queryContextCommand = vscode.commands.registerCommand('badger.queryContext', async () => {\n        const query = await vscode.window.showInputBox({\n            prompt: 'Enter code elements to find context for',\n            placeHolder: 'functionName, ClassName, variableName'\n        });\n\n        if (query) {\n            vscode.window.showInformationMessage(`Querying context for: ${query}`);\n\n            // TODO: Implement context querying logic\n            // - Parse user query to identify code elements\n            // - Query Dgraph graph database\n            // - Return relevant context\n        }\n    });\n\n    // Register the update graph command\n    const updateGraphCommand = vscode.commands.registerCommand('badger.updateGraph', () => {\n        vscode.window.showInformationMessage('Updating code graph...');\n\n        // TODO: Implement graph update logic\n        // - Detect changed files\n        // - Re-parse with tree-sitter\n        // - Update Dgraph with changes\n    });\n\n    // Register file save listener for automatic updates\n    const fileSaveListener = vscode.workspace.onDidSaveTextDocument((document) => {\n        // TODO: Implement automatic graph updates on file save\n        console.log(`File saved: ${document.fileName}`);\n    });\n\n    // Add all disposables to context\n    context.subscriptions.push(\n        indexWorkspaceCommand,\n        parseCurrentFileCommand,\n        queryContextCommand,\n        updateGraphCommand,\n        fileSaveListener\n    );\n\n    console.log(' Badger extension activation completed successfully!');\n}\n\nexport function deactivate() {\n    console.log('Badger extension deactivated');\n}\n","module.exports = require(\"vscode\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"fs/promises\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; (typeof current == 'object' || typeof current == 'function') && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(144);\n",""],"names":[],"sourceRoot":""}